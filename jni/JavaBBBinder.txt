
typedef int32_t     status_t;

template <class TYPE>
class Vector : private VectorImpl
{
public:
            typedef TYPE    value_type;

    /*!
     * Constructors and destructors
     */

                            Vector();
                            Vector(const Vector<TYPE>& rhs);
    virtual                 ~Vector();

    /*! copy operator */
            const Vector<TYPE>&     operator = (const Vector<TYPE>& rhs) const;
            Vector<TYPE>&           operator = (const Vector<TYPE>& rhs);

    /*
     * empty the vector
     */

    inline  void            clear()             { VectorImpl::clear(); }

    /*!
     * vector stats
     */

    //! returns number of items in the vector
    inline  size_t          size() const                { return VectorImpl::size(); }
    //! returns wether or not the vector is empty
    inline  bool            isEmpty() const             { return VectorImpl::isEmpty(); }
    //! returns how many items can be stored without reallocating the backing store
    inline  size_t          capacity() const            { return VectorImpl::capacity(); }
    //! setst the capacity. capacity can never be reduced less than size()
    inline  ssize_t         setCapacity(size_t size)    { return VectorImpl::setCapacity(size); }

    /*!
     * C-style array access
     */

    //! read-only C-style access
    inline  const TYPE*     array() const;
    //! read-write C-style access
            TYPE*           editArray();

    /*!
     * accessors
     */

    //! read-only access to an item at a given index
    inline  const TYPE&     operator [] (size_t index) const;
    //! alternate name for operator []
    inline  const TYPE&     itemAt(size_t index) const;
    //! stack-usage of the vector. returns the top of the stack (last element)
            const TYPE&     top() const;
    //! same as operator [], but allows to access the vector backward (from the end) with a negative index
            const TYPE&     mirrorItemAt(ssize_t index) const;

    /*!
     * modifing the array
     */

    //! copy-on write support, grants write access to an item
            TYPE&           editItemAt(size_t index);
    //! grants right acces to the top of the stack (last element)
            TYPE&           editTop();

            /*!
             * append/insert another vector
             */

    //! insert another vector at a given index
            ssize_t         insertVectorAt(const Vector<TYPE>& vector, size_t index);

    //! append another vector at the end of this one
            ssize_t         appendVector(const Vector<TYPE>& vector);


    //! insert an array at a given index
            ssize_t         insertArrayAt(const TYPE* array, size_t index, size_t length);

    //! append an array at the end of this vector
            ssize_t         appendArray(const TYPE* array, size_t length);

            /*!
             * add/insert/replace items
             */

    //! insert one or several items initialized with their default constructor
    inline  ssize_t         insertAt(size_t index, size_t numItems = 1);
    //! insert one or several items initialized from a prototype item
            ssize_t         insertAt(const TYPE& prototype_item, size_t index, size_t numItems = 1);
    //! pop the top of the stack (removes the last element). No-op if the stack's empty
    inline  void            pop();
    //! pushes an item initialized with its default constructor
    inline  void            push();
    //! pushes an item on the top of the stack
            void            push(const TYPE& item);
    //! same as push() but returns the index the item was added at (or an error)
    inline  ssize_t         add();
    //! same as push() but returns the index the item was added at (or an error)
            ssize_t         add(const TYPE& item);
    //! replace an item with a new one initialized with its default constructor
    inline  ssize_t         replaceAt(size_t index);
    //! replace an item with a new one
            ssize_t         replaceAt(const TYPE& item, size_t index);

    /*!
     * remove items
     */

    //! remove several items
    inline  ssize_t         removeItemsAt(size_t index, size_t count = 1);
    //! remove one item
    inline  ssize_t         removeAt(size_t index)  { return removeItemsAt(index); }

    /*!
     * sort (stable) the array
     */

     typedef int (*compar_t)(const TYPE* lhs, const TYPE* rhs);
     typedef int (*compar_r_t)(const TYPE* lhs, const TYPE* rhs, void* state);

     inline status_t        sort(compar_t cmp);
     inline status_t        sort(compar_r_t cmp, void* state);

protected:
    virtual void    do_construct(void* storage, size_t num) const;
    virtual void    do_destroy(void* storage, size_t num) const;
    virtual void    do_copy(void* dest, const void* from, size_t num) const;
    virtual void    do_splat(void* dest, const void* item, size_t num) const;
    virtual void    do_move_forward(void* dest, const void* from, size_t num) const;
    virtual void    do_move_backward(void* dest, const void* from, size_t num) const;
};


// ---------------------------------------------------------------------------
// No user serviceable parts from here...
// ---------------------------------------------------------------------------


class VectorImpl
{
public:
    enum { // flags passed to the ctor
        HAS_TRIVIAL_CTOR    = 0x00000001,
        HAS_TRIVIAL_DTOR    = 0x00000002,
        HAS_TRIVIAL_COPY    = 0x00000004,
    };

                            VectorImpl(size_t itemSize, uint32_t flags);
                            VectorImpl(const VectorImpl& rhs);
    virtual                 ~VectorImpl();

    /*! must be called from subclasses destructor */
            void            finish_vector();

            VectorImpl&     operator = (const VectorImpl& rhs);

    /*! C-style array access */
    inline  const void*     arrayImpl() const       { return mStorage; }
            void*           editArrayImpl();

    /*! vector stats */
    inline  size_t          size() const        { return mCount; }
    inline  bool            isEmpty() const     { return mCount == 0; }
            size_t          capacity() const;
            ssize_t         setCapacity(size_t size);

            /*! append/insert another vector or array */
            ssize_t         insertVectorAt(const VectorImpl& vector, size_t index);
            ssize_t         appendVector(const VectorImpl& vector);
            ssize_t         insertArrayAt(const void* array, size_t index, size_t length);
            ssize_t         appendArray(const void* array, size_t length);

            /*! add/insert/replace items */
            ssize_t         insertAt(size_t where, size_t numItems = 1);
            ssize_t         insertAt(const void* item, size_t where, size_t numItems = 1);
            void            pop();
            void            push();
            void            push(const void* item);
            ssize_t         add();
            ssize_t         add(const void* item);
            ssize_t         replaceAt(size_t index);
            ssize_t         replaceAt(const void* item, size_t index);

            /*! remove items */
            ssize_t         removeItemsAt(size_t index, size_t count = 1);
            void            clear();

            const void*     itemLocation(size_t index) const;
            void*           editItemLocation(size_t index);

            typedef int (*compar_t)(const void* lhs, const void* rhs);
            typedef int (*compar_r_t)(const void* lhs, const void* rhs, void* state);
            status_t        sort(compar_t cmp);
            status_t        sort(compar_r_t cmp, void* state);

protected:
            size_t          itemSize() const;
            void            release_storage();

    virtual void            do_construct(void* storage, size_t num) const = 0;
    virtual void            do_destroy(void* storage, size_t num) const = 0;
    virtual void            do_copy(void* dest, const void* from, size_t num) const = 0;
    virtual void            do_splat(void* dest, const void* item, size_t num) const = 0;
    virtual void            do_move_forward(void* dest, const void* from, size_t num) const = 0;
    virtual void            do_move_backward(void* dest, const void* from, size_t num) const = 0;

    // take care of FBC...
    virtual void            reservedVectorImpl1();
    virtual void            reservedVectorImpl2();
    virtual void            reservedVectorImpl3();
    virtual void            reservedVectorImpl4();
    virtual void            reservedVectorImpl5();
    virtual void            reservedVectorImpl6();
    virtual void            reservedVectorImpl7();
    virtual void            reservedVectorImpl8();

private:
        void* _grow(size_t where, size_t amount);
        void  _shrink(size_t where, size_t amount);

        inline void _do_construct(void* storage, size_t num) const;
        inline void _do_destroy(void* storage, size_t num) const;
        inline void _do_copy(void* dest, const void* from, size_t num) const;
        inline void _do_splat(void* dest, const void* item, size_t num) const;
        inline void _do_move_forward(void* dest, const void* from, size_t num) const;
        inline void _do_move_backward(void* dest, const void* from, size_t num) const;

            // These 2 fields are exposed in the inlines below,
            // so they're set in stone.
            void *      mStorage;   // base address of the vector
            size_t      mCount;     // number of items

    const   uint32_t    mFlags;
    const   size_t      mItemSize;
};





template<class TYPE> inline
Vector<TYPE>::Vector()
    : VectorImpl(sizeof(TYPE), 0)
{
}

template<class TYPE> inline
Vector<TYPE>::Vector(const Vector<TYPE>& rhs)
    : VectorImpl(rhs) {
}

template<class TYPE> inline
Vector<TYPE>::~Vector() {
    finish_vector();
}

template<class TYPE> inline
Vector<TYPE>& Vector<TYPE>::operator = (const Vector<TYPE>& rhs) {
    VectorImpl::operator = (rhs);
    return *this;
}

template<class TYPE> inline
const Vector<TYPE>& Vector<TYPE>::operator = (const Vector<TYPE>& rhs) const {
    VectorImpl::operator = (rhs);
    return *this;
}

template<class TYPE> inline
const TYPE* Vector<TYPE>::array() const {
    return static_cast<const TYPE *>(arrayImpl());
}

template<class TYPE> inline
TYPE* Vector<TYPE>::editArray() {
    return static_cast<TYPE *>(editArrayImpl());
}


template<class TYPE> inline
const TYPE& Vector<TYPE>::operator[](size_t index) const {
   return *(array() + index);
}

template<class TYPE> inline
const TYPE& Vector<TYPE>::itemAt(size_t index) const {
    return operator[](index);
}

template<class TYPE> inline
const TYPE& Vector<TYPE>::mirrorItemAt(ssize_t index) const {
    return *(array() + ((index<0) ? (size()-index) : index));
}

template<class TYPE> inline
const TYPE& Vector<TYPE>::top() const {
    return *(array() + size() - 1);
}

template<class TYPE> inline
TYPE& Vector<TYPE>::editItemAt(size_t index) {
    return *( static_cast<TYPE *>(editItemLocation(index)) );
}

template<class TYPE> inline
TYPE& Vector<TYPE>::editTop() {
    return *( static_cast<TYPE *>(editItemLocation(size()-1)) );
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertVectorAt(const Vector<TYPE>& vector, size_t index) {
    return VectorImpl::insertVectorAt(reinterpret_cast<const VectorImpl&>(vector), index);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::appendVector(const Vector<TYPE>& vector) {
    return VectorImpl::appendVector(reinterpret_cast<const VectorImpl&>(vector));
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertArrayAt(const TYPE* array, size_t index, size_t length) {
    return VectorImpl::insertArrayAt(array, index, length);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::appendArray(const TYPE* array, size_t length) {
    return VectorImpl::appendArray(array, length);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertAt(const TYPE& item, size_t index, size_t numItems) {
    return VectorImpl::insertAt(&item, index, numItems);
}

template<class TYPE> inline
void Vector<TYPE>::push(const TYPE& item) {
    return VectorImpl::push(&item);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::add(const TYPE& item) {
    return VectorImpl::add(&item);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::replaceAt(const TYPE& item, size_t index) {
    return VectorImpl::replaceAt(&item, index);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertAt(size_t index, size_t numItems) {
    return VectorImpl::insertAt(index, numItems);
}

template<class TYPE> inline
void Vector<TYPE>::pop() {
    VectorImpl::pop();
}

template<class TYPE> inline
void Vector<TYPE>::push() {
    VectorImpl::push();
}

template<class TYPE> inline
ssize_t Vector<TYPE>::add() {
    return VectorImpl::add();
}

template<class TYPE> inline
ssize_t Vector<TYPE>::replaceAt(size_t index) {
    return VectorImpl::replaceAt(index);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::removeItemsAt(size_t index, size_t count) {
    return VectorImpl::removeItemsAt(index, count);
}

template<class TYPE> inline
status_t Vector<TYPE>::sort(Vector<TYPE>::compar_t cmp) {
    return VectorImpl::sort((VectorImpl::compar_t)cmp);
}

template<class TYPE> inline
status_t Vector<TYPE>::sort(Vector<TYPE>::compar_r_t cmp, void* state) {
    return VectorImpl::sort((VectorImpl::compar_r_t)cmp, state);
}

// ---------------------------------------------------------------------------

template<class TYPE>
void Vector<TYPE>::do_construct(void* storage, size_t num) const {
    construct_type( reinterpret_cast<TYPE*>(storage), num );
}

template<class TYPE>
void Vector<TYPE>::do_destroy(void* storage, size_t num) const {
    destroy_type( reinterpret_cast<TYPE*>(storage), num );
}

template<class TYPE>
void Vector<TYPE>::do_copy(void* dest, const void* from, size_t num) const {
    copy_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

template<class TYPE>
void Vector<TYPE>::do_splat(void* dest, const void* item, size_t num) const {
    splat_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(item), num );
}

template<class TYPE>
void Vector<TYPE>::do_move_forward(void* dest, const void* from, size_t num) const {
    move_forward_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

template<class TYPE>
void Vector<TYPE>::do_move_backward(void* dest, const void* from, size_t num) const {
    move_backward_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

class SortedVectorImpl : public VectorImpl
{
public:
                            SortedVectorImpl(size_t itemSize, uint32_t flags);
                            SortedVectorImpl(const VectorImpl& rhs);
    virtual                 ~SortedVectorImpl();

    SortedVectorImpl&     operator = (const SortedVectorImpl& rhs);

    //! finds the index of an item
            ssize_t         indexOf(const void* item) const;

    //! finds where this item should be inserted
            size_t          orderOf(const void* item) const;

    //! add an item in the right place (or replaces it if there is one)
            ssize_t         add(const void* item);

    //! merges a vector into this one
            ssize_t         merge(const VectorImpl& vector);
            ssize_t         merge(const SortedVectorImpl& vector);

    //! removes an item
            ssize_t         remove(const void* item);

protected:
    virtual int             do_compare(const void* lhs, const void* rhs) const = 0;

    // take care of FBC...
    virtual void            reservedSortedVectorImpl1();
    virtual void            reservedSortedVectorImpl2();
    virtual void            reservedSortedVectorImpl3();
    virtual void            reservedSortedVectorImpl4();
    virtual void            reservedSortedVectorImpl5();
    virtual void            reservedSortedVectorImpl6();
    virtual void            reservedSortedVectorImpl7();
    virtual void            reservedSortedVectorImpl8();

private:
            ssize_t         _indexOrderOf(const void* item, size_t* order = 0) const;

            // these are made private, because they can't be used on a SortedVector
            // (they don't have an implementation either)
            ssize_t         add();
            void            pop();
            void            push();
            void            push(const void* item);
            ssize_t         insertVectorAt(const VectorImpl& vector, size_t index);
            ssize_t         appendVector(const VectorImpl& vector);
            ssize_t         insertArrayAt(const void* array, size_t index, size_t length);
            ssize_t         appendArray(const void* array, size_t length);
            ssize_t         insertAt(size_t where, size_t numItems = 1);
            ssize_t         insertAt(const void* item, size_t where, size_t numItems = 1);
            ssize_t         replaceAt(size_t index);
            ssize_t         replaceAt(const void* item, size_t index);
};

template <class TYPE>
class SortedVector : private SortedVectorImpl
{
public:
            typedef TYPE    value_type;

    /*!
     * Constructors and destructors
     */

                            SortedVector();
                            SortedVector(const SortedVector<TYPE>& rhs);
    virtual                 ~SortedVector();

    /*! copy operator */
    const SortedVector<TYPE>&   operator = (const SortedVector<TYPE>& rhs) const;
    SortedVector<TYPE>&         operator = (const SortedVector<TYPE>& rhs);

    /*
     * empty the vector
     */

    inline  void            clear()             { VectorImpl::clear(); }

    /*!
     * vector stats
     */

    //! returns number of items in the vector
    inline  size_t          size() const                { return VectorImpl::size(); }
    //! returns wether or not the vector is empty
    inline  bool            isEmpty() const             { return VectorImpl::isEmpty(); }
    //! returns how many items can be stored without reallocating the backing store
    inline  size_t          capacity() const            { return VectorImpl::capacity(); }
    //! setst the capacity. capacity can never be reduced less than size()
    inline  ssize_t         setCapacity(size_t size)    { return VectorImpl::setCapacity(size); }

    /*!
     * C-style array access
     */

    //! read-only C-style access
    inline  const TYPE*     array() const;

    //! read-write C-style access. BE VERY CAREFUL when modifying the array
    //! you ust keep it sorted! You usually don't use this function.
            TYPE*           editArray();

            //! finds the index of an item
            ssize_t         indexOf(const TYPE& item) const;

            //! finds where this item should be inserted
            size_t          orderOf(const TYPE& item) const;


    /*!
     * accessors
     */

    //! read-only access to an item at a given index
    inline  const TYPE&     operator [] (size_t index) const;
    //! alternate name for operator []
    inline  const TYPE&     itemAt(size_t index) const;
    //! stack-usage of the vector. returns the top of the stack (last element)
            const TYPE&     top() const;
    //! same as operator [], but allows to access the vector backward (from the end) with a negative index
            const TYPE&     mirrorItemAt(ssize_t index) const;

    /*!
     * modifing the array
     */

            //! add an item in the right place (and replace the one that is there)
            ssize_t         add(const TYPE& item);

            //! editItemAt() MUST NOT change the order of this item
            TYPE&           editItemAt(size_t index) {
                return *( static_cast<TYPE *>(VectorImpl::editItemLocation(index)) );
            }

            //! merges a vector into this one
            ssize_t         merge(const Vector<TYPE>& vector);
            ssize_t         merge(const SortedVector<TYPE>& vector);

            //! removes an item
            ssize_t         remove(const TYPE&);

    //! remove several items
    inline  ssize_t         removeItemsAt(size_t index, size_t count = 1);
    //! remove one item
    inline  ssize_t         removeAt(size_t index)  { return removeItemsAt(index); }

protected:
    virtual void    do_construct(void* storage, size_t num) const;
    virtual void    do_destroy(void* storage, size_t num) const;
    virtual void    do_copy(void* dest, const void* from, size_t num) const;
    virtual void    do_splat(void* dest, const void* item, size_t num) const;
    virtual void    do_move_forward(void* dest, const void* from, size_t num) const;
    virtual void    do_move_backward(void* dest, const void* from, size_t num) const;
    virtual int     do_compare(const void* lhs, const void* rhs) const;
};


// ---------------------------------------------------------------------------
// No user serviceable parts from here...
// ---------------------------------------------------------------------------

template<class TYPE> inline
SortedVector<TYPE>::SortedVector()
    : SortedVectorImpl(sizeof(TYPE), 0)
{
}

template<class TYPE> inline
SortedVector<TYPE>::SortedVector(const SortedVector<TYPE>& rhs)
    : SortedVectorImpl(rhs) {
}

template<class TYPE> inline
SortedVector<TYPE>::~SortedVector() {
    finish_vector();
}

template<class TYPE> inline
SortedVector<TYPE>& SortedVector<TYPE>::operator = (const SortedVector<TYPE>& rhs) {
    SortedVectorImpl::operator = (rhs);
    return *this;
}

template<class TYPE> inline
const SortedVector<TYPE>& SortedVector<TYPE>::operator = (const SortedVector<TYPE>& rhs) const {
    SortedVectorImpl::operator = (rhs);
    return *this;
}

template<class TYPE> inline
const TYPE* SortedVector<TYPE>::array() const {
    return static_cast<const TYPE *>(arrayImpl());
}

template<class TYPE> inline
TYPE* SortedVector<TYPE>::editArray() {
    return static_cast<TYPE *>(editArrayImpl());
}


template<class TYPE> inline
const TYPE& SortedVector<TYPE>::operator[](size_t index) const {
    assert( index<size() );
    return *(array() + index);
}

template<class TYPE> inline
const TYPE& SortedVector<TYPE>::itemAt(size_t index) const {
    return operator[](index);
}

template<class TYPE> inline
const TYPE& SortedVector<TYPE>::mirrorItemAt(ssize_t index) const {
    assert( (index>0 ? index : -index)<size() );
    return *(array() + ((index<0) ? (size()-index) : index));
}

template<class TYPE> inline
const TYPE& SortedVector<TYPE>::top() const {
    return *(array() + size() - 1);
}

template<class TYPE> inline
ssize_t SortedVector<TYPE>::add(const TYPE& item) {
    return SortedVectorImpl::add(&item);
}

template<class TYPE> inline
ssize_t SortedVector<TYPE>::indexOf(const TYPE& item) const {
    return SortedVectorImpl::indexOf(&item);
}

template<class TYPE> inline
size_t SortedVector<TYPE>::orderOf(const TYPE& item) const {
    return SortedVectorImpl::orderOf(&item);
}

template<class TYPE> inline
ssize_t SortedVector<TYPE>::merge(const Vector<TYPE>& vector) {
    return SortedVectorImpl::merge(reinterpret_cast<const VectorImpl&>(vector));
}

template<class TYPE> inline
ssize_t SortedVector<TYPE>::merge(const SortedVector<TYPE>& vector) {
    return SortedVectorImpl::merge(reinterpret_cast<const SortedVectorImpl&>(vector));
}

template<class TYPE> inline
ssize_t SortedVector<TYPE>::remove(const TYPE& item) {
    return SortedVectorImpl::remove(&item);
}

template<class TYPE> inline
ssize_t SortedVector<TYPE>::removeItemsAt(size_t index, size_t count) {
    return VectorImpl::removeItemsAt(index, count);
}

// ---------------------------------------------------------------------------

template<class TYPE>
void SortedVector<TYPE>::do_construct(void* storage, size_t num) const {
    construct_type( reinterpret_cast<TYPE*>(storage), num );
}

template<class TYPE>
void SortedVector<TYPE>::do_destroy(void* storage, size_t num) const {
    destroy_type( reinterpret_cast<TYPE*>(storage), num );
}

template<class TYPE>
void SortedVector<TYPE>::do_copy(void* dest, const void* from, size_t num) const {
    copy_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

template<class TYPE>
void SortedVector<TYPE>::do_splat(void* dest, const void* item, size_t num) const {
    splat_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(item), num );
}

template<class TYPE>
void SortedVector<TYPE>::do_move_forward(void* dest, const void* from, size_t num) const {
    move_forward_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

template<class TYPE>
void SortedVector<TYPE>::do_move_backward(void* dest, const void* from, size_t num) const {
    move_backward_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

template<class TYPE>
int SortedVector<TYPE>::do_compare(const void* lhs, const void* rhs) const {
    return compare_type( *reinterpret_cast<const TYPE*>(lhs), *reinterpret_cast<const TYPE*>(rhs) );
}

template <typename KEY, typename VALUE>
class KeyedVector
{
public:
    typedef KEY    key_type;
    typedef VALUE  value_type;

    inline                  KeyedVector();

    /*
     * empty the vector
     */

    inline  void            clear()                     { mVector.clear(); }

    /*!
     * vector stats
     */

    //! returns number of items in the vector
    inline  size_t          size() const                { return mVector.size(); }
    //! returns wether or not the vector is empty
    inline  bool            isEmpty() const             { return mVector.isEmpty(); }
    //! returns how many items can be stored without reallocating the backing store
    inline  size_t          capacity() const            { return mVector.capacity(); }
    //! setst the capacity. capacity can never be reduced less than size()
    inline ssize_t          setCapacity(size_t size)    { return mVector.setCapacity(size); }

    /*!
     * accessors
     */
            const VALUE&    valueFor(const KEY& key) const;
            const VALUE&    valueAt(size_t index) const;
            const KEY&      keyAt(size_t index) const;
            ssize_t         indexOfKey(const KEY& key) const;

    /*!
     * modifing the array
     */

            VALUE&          editValueFor(const KEY& key);
            VALUE&          editValueAt(size_t index);

            /*!
             * add/insert/replace items
             */

            ssize_t         add(const KEY& key, const VALUE& item);
            ssize_t         replaceValueFor(const KEY& key, const VALUE& item);
            ssize_t         replaceValueAt(size_t index, const VALUE& item);

    /*!
     * remove items
     */

            ssize_t         removeItem(const KEY& key);
            ssize_t         removeItemsAt(size_t index, size_t count = 1);

private:
            SortedVector< key_value_pair_t<KEY, VALUE> >    mVector;
};

// ---------------------------------------------------------------------------

/**
 * Variation of KeyedVector that holds a default value to return when
 * valueFor() is called with a key that doesn't exist.
 */
template <typename KEY, typename VALUE>
class DefaultKeyedVector : public KeyedVector<KEY, VALUE>
{
public:
    inline                  DefaultKeyedVector(const VALUE& defValue = VALUE());
            const VALUE&    valueFor(const KEY& key) const;

private:
            VALUE                                           mDefault;
};

// ---------------------------------------------------------------------------

template<typename KEY, typename VALUE> inline
KeyedVector<KEY,VALUE>::KeyedVector()
{
}

template<typename KEY, typename VALUE> inline
ssize_t KeyedVector<KEY,VALUE>::indexOfKey(const KEY& key) const {
    return mVector.indexOf( key_value_pair_t<KEY,VALUE>(key) );
}

template<typename KEY, typename VALUE> inline
const VALUE& KeyedVector<KEY,VALUE>::valueFor(const KEY& key) const {
    ssize_t i = indexOfKey(key);
    assert(i>=0);
    return mVector.itemAt(i).value;
}

template<typename KEY, typename VALUE> inline
const VALUE& KeyedVector<KEY,VALUE>::valueAt(size_t index) const {
    return mVector.itemAt(index).value;
}

template<typename KEY, typename VALUE> inline
const KEY& KeyedVector<KEY,VALUE>::keyAt(size_t index) const {
    return mVector.itemAt(index).key;
}

template<typename KEY, typename VALUE> inline
VALUE& KeyedVector<KEY,VALUE>::editValueFor(const KEY& key) {
    ssize_t i = indexOfKey(key);
    assert(i>=0);
    return mVector.editItemAt(i).value;
}

template<typename KEY, typename VALUE> inline
VALUE& KeyedVector<KEY,VALUE>::editValueAt(size_t index) {
    return mVector.editItemAt(index).value;
}

template<typename KEY, typename VALUE> inline
ssize_t KeyedVector<KEY,VALUE>::add(const KEY& key, const VALUE& value) {
    return mVector.add( key_value_pair_t<KEY,VALUE>(key, value) );
}

template<typename KEY, typename VALUE> inline
ssize_t KeyedVector<KEY,VALUE>::replaceValueFor(const KEY& key, const VALUE& value) {
    key_value_pair_t<KEY,VALUE> pair(key, value);
    mVector.remove(pair);
    return mVector.add(pair);
}

template<typename KEY, typename VALUE> inline
ssize_t KeyedVector<KEY,VALUE>::replaceValueAt(size_t index, const VALUE& item) {
    if (index<size()) {
        mVector.editItemAt(index).value = item;
        return index;
    }
    return -1;
}

template<typename KEY, typename VALUE> inline
ssize_t KeyedVector<KEY,VALUE>::removeItem(const KEY& key) {
    return mVector.remove(key_value_pair_t<KEY,VALUE>(key));
}

template<typename KEY, typename VALUE> inline
ssize_t KeyedVector<KEY, VALUE>::removeItemsAt(size_t index, size_t count) {
    return mVector.removeItemsAt(index, count);
}

// ---------------------------------------------------------------------------

template<typename KEY, typename VALUE> inline
DefaultKeyedVector<KEY,VALUE>::DefaultKeyedVector(const VALUE& defValue)
    : mDefault(defValue)
{
}

template<typename KEY, typename VALUE> inline
const VALUE& DefaultKeyedVector<KEY,VALUE>::valueFor(const KEY& key) const {
    ssize_t i = indexOfKey(key);
    return i >= 0 ? KeyedVector<KEY,VALUE>::valueAt(i) : mDefault;
}







typedef struct
{
     int volatile value;
} pthread_mutex_t;

class Mutex {
 public:

 private:
     friend class Condition;
     Mutex&      operator = (const Mutex&) { return *this; }

     void*   mState;
 };

class RefBase
{
protected:
    RefBase();
    virtual ~RefBase() {};
	virtual void onFirstRef() {};
	virtual void onLastStrongRef() {};
	virtual void onIncStrongAttempted() {};
	virtual void onLastWeakRef() {};

    RefBase(const RefBase& o) { mRefs=NULL; };
    RefBase& operator=(const RefBase& o) { return *this; };

public:
	void* mRefs;
};

template <typename T>
class sp
{
private:
    sp(T* other) { m_ptr=other; };

    sp(const sp<T>& other) { m_ptr=NULL; };
    template<typename U> sp(U* other) { m_ptr=NULL; };
    template<typename U> sp(const sp<U>& other) { m_ptr=NULL; };

    sp& operator = (T* other) { return *this; }
    sp& operator = (const sp<T>& other) { return *this; }

    template<typename U> sp& operator = (const sp<U>& other) { return *this; }
    template<typename U> sp& operator = (U* other) { return *this; }

    inline  T& operator* () const { return *m_ptr; }
    inline  T* operator-> () const { return m_ptr;  }
    inline  T* get() const { return m_ptr; }

    template<typename Y> friend class sp;
    template<typename Y> friend class wp;

public:
    T* m_ptr;
};

template <typename T>
class wp
{
private:
    wp(T* other) { m_ptr=NULL; m_refs=NULL; };
    wp(const wp<T>& other) { m_ptr=NULL; m_refs=NULL; };
    wp(const sp<T>& other) { m_ptr=NULL; m_refs=NULL; };
    template<typename U> wp(U* other) { m_ptr=NULL; m_refs=NULL; };
    template<typename U> wp(const sp<U>& other) { m_ptr=NULL; m_refs=NULL; };
    template<typename U> wp(const wp<U>& other) { m_ptr=NULL; m_refs=NULL; };

    wp& operator = (T* other) { return *this; }
    wp& operator = (const wp<T>& other) { return *this; }
    wp& operator = (const sp<T>& other) { return *this; }

    template<typename U> wp& operator = (U* other) { return *this; }
    template<typename U> wp& operator = (const wp<U>& other) { return *this; }
    template<typename U> wp& operator = (const sp<U>& other) { return *this; }

    template<typename U> inline bool operator != (const wp<U>& o) const { return true; }
    template<typename U> inline bool operator <= (const wp<U>& o) const { return true; }
    template<typename U> inline bool operator >= (const wp<U>& o) const { return true; }

    sp<T> promote() { return sp<T>(m_ptr); }

    template<typename Y> friend class sp;
    template<typename Y> friend class wp;

public:
    T* m_ptr;
    void* m_refs;
};

class IBinder : public virtual RefBase
{
public:
    virtual void queryLocalInterface() {};
    virtual void getInterfaceDescriptor() = 0;
    virtual void isBinderAlive() = 0;
    virtual void pingBinder() = 0;
    virtual void dump() = 0;
    virtual void transact() = 0;
    virtual void linkToDeath() = 0;
    virtual void unlinkToDeath() = 0;
    virtual void checkSubclass();
    virtual void attachObject() = 0;
    virtual void findObject() = 0;
    virtual void detachObject() = 0;
    virtual void localBinder() {};
    virtual void remoteBinder() {};
protected:
    virtual ~IBinder();
};



class BpBinder : public IBinder
{
public:
                        BpBinder();

    virtual void        getInterfaceDescriptor() {};
    virtual void        isBinderAlive() {};
    virtual void    pingBinder() {};
    virtual void    dump() {};

    virtual void    transact() {};

    virtual void    linkToDeath() {};
    virtual void    unlinkToDeath() {};

    virtual void        attachObject() {};
    virtual void       findObject() {};
    virtual void        detachObject() {};

    virtual void   remoteBinder() {};

    void    setConstantData() {};
            void        sendObituary() {};

    class ObjectManager
    {
    public:
                    ObjectManager() {};
                    ~ObjectManager() {};

        void        attach() {};
        void        find() {};
        void        detach() {};
        void        kill() {};

    private:
                    ObjectManager(const ObjectManager&);
        ObjectManager& operator=(const ObjectManager&);

        struct entry_t
        {
            void* object;
            void* cleanupCookie;
            void* func;
        };

        KeyedVector<const void*, entry_t> mObjects;
    };

protected:
    virtual             ~BpBinder() {};
    virtual void        onFirstRef() {};
    virtual void        onLastStrongRef() {};
    virtual void        onIncStrongAttempted() {};

private:
    const   int32_t             mHandle;

    struct Obituary {
        wp<IBinder> recipient;
        void* cookie;
        uint32_t flags;
    };

            void                reportOneDeath() {};
            bool                isDescriptorCached() {};

    mutable Mutex               mLock;
            volatile int32_t    mAlive;
            volatile int32_t    mObitsSent;
            Vector<Obituary>*   mObituaries;
            ObjectManager       mObjects;
            void*               mConstantData;
    mutable int*                 mDescriptorCache;
};






























class BBinder : public IBinder
{
public:
    virtual void getInterfaceDescriptor() {};
    virtual void isBinderAlive() {};
    virtual void pingBinder() {};
    virtual void dump() {};
    virtual void transact() {};
    virtual void linkToDeath() {};
    virtual void unlinkToDeath() {};
    virtual void attachObject() {};
    virtual void findObject() {};
    virtual void detachObject() {};
    virtual void localBinder() {};

protected:
    virtual ~BBinder() {};
    virtual void onTransact() {};

private:
    BBinder(const BBinder& o) { mExtras=NULL; mReserved0=NULL; };
    BBinder& operator=(const BBinder& o) { return *this; };

	void* mExtras;
	void* mReserved0;
};

class JavaBBinder : public BBinder
{
private:
    jobject object() { return mObject; }
    void checkSubclass() { }

protected:
    virtual ~JavaBBinder() {};
    virtual void onTransact() {};
    virtual void dump() {};

public:
    void* mVM;
    jobject const mObject;
};

class JavaBBinderHolder : public RefBase
{
private:
	void get() {}
	Mutex mLock;
public:
    wp<JavaBBinder> mBinder;
};






















////////////////////////////////////////////////////////////////////////////




















































































































template <typename KEY, typename VALUE>
class KeyedVector
{
public:
    typedef KEY    key_type;
    typedef VALUE  value_type;

    inline                  KeyedVector();

    /*
     * empty the vector
     */

    inline  void            clear()                     { mVector.clear(); }

    /*! 
     * vector stats
     */

    //! returns number of items in the vector
    inline  size_t          size() const                { return mVector.size(); }
    //! returns wether or not the vector is empty
    inline  bool            isEmpty() const             { return mVector.isEmpty(); }
    //! returns how many items can be stored without reallocating the backing store
    inline  size_t          capacity() const            { return mVector.capacity(); }
    //! setst the capacity. capacity can never be reduced less than size()
    inline ssize_t          setCapacity(size_t size)    { return mVector.setCapacity(size); }
    
    /*! 
     * accessors
     */
            const VALUE&    valueFor(const KEY& key) const;
            const VALUE&    valueAt(size_t index) const;
            const KEY&      keyAt(size_t index) const;
            ssize_t         indexOfKey(const KEY& key) const;

    /*!
     * modifing the array
     */

            VALUE&          editValueFor(const KEY& key);
            VALUE&          editValueAt(size_t index);

            /*! 
             * add/insert/replace items
             */
             
            ssize_t         add(const KEY& key, const VALUE& item);
            ssize_t         replaceValueFor(const KEY& key, const VALUE& item);
            ssize_t         replaceValueAt(size_t index, const VALUE& item);

    /*!
     * remove items
     */

            ssize_t         removeItem(const KEY& key);
            ssize_t         removeItemsAt(size_t index, size_t count = 1);
            
private:
            < key_value_pair_t<KEY, VALUE> >    mVector;
};

class ObjectManager
{
public:
	ObjectManager() {}
   ~ObjectManager() {}

private:
   ObjectManager(const ObjectManager&);
ObjectManager& operator=(const ObjectManager&);
	struct entry_t
	{
		void* object;
		void* cleanupCookie;
		void* func;
	};
	KeyedVector<const void*, entry_t> mObjects;
};






void* nIBinder = (void*);
void* nBpBinder = (void*);


virtual
const int32_t BpBinder::mHandle;
ObjectManager BpBinder::mObjects;
KeyedVector<const void*, entry_t> ObjectManager::mObjects;

status_t BpBinder::transact(
    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
    // Once a binder has died, it will never come back to life.
    if (mAlive) {
        status_t status = IPCThreadState::self()->transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}

void* ObjectManager::find(const void* objectID) const
{
    const ssize_t i = mObjects.indexOfKey(objectID);
    if (i < 0) return NULL;
    return mObjects.valueAt(i).object;
}






jclass c = env->GetObjectClass(obj);
jfieldID f = env->GetFieldID(c, "mObject", "I");

w->jmidTFrameTRun = w->env->GetMethodID(jclassTFrame, "tRun", "(JJJJJ)J");
mObject
IBinder* target = (void*)env->GetIntField(obj, gBinderProxyOffsets.mObject);







E:\DocDev\android-x86\platform\base\core\jni\android_util_Binder.cpp(799):     IBinder* target = (IBinder*) env->GetIntField(obj, gBinderProxyOffsets.mObject);
IBinder* target = (IBinder*)
        env->GetIntField(obj, gBinderProxyOffsets.mObject);
if (env->IsInstanceOf(obj, gBinderProxyOffsets.mClass)) {
    return (IBinder*)
        env->GetIntField(obj, gBinderProxyOffsets.mObject);
}

void**** jbh = (void****)a;
void*** binder = (void***)jbh[7];
void** m_ptr = (void**)binder[0];
void* object = (void*)m_ptr[7];

//JavaBBinderHolder* jbh = (JavaBBinderHolder*)a;
//jobject object = jbh->mBinder.m_ptr->mObject;
static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,
                                                jint code, jobject dataObj,
                                                jobject replyObj, jint flags)
{
    if (dataObj == NULL) {
        jniThrowException(env, "java/lang/NullPointerException", NULL);
        return JNI_FALSE;
    }

    Parcel* data = parcelForJavaObject(env, dataObj);
    if (data == NULL) {
        return JNI_FALSE;
    }
    Parcel* reply = parcelForJavaObject(env, replyObj);
    if (reply == NULL && replyObj != NULL) {
        return JNI_FALSE;
    }

    IBinder* target = (IBinder*)
        env->GetIntField(obj, gBinderProxyOffsets.mObject);
    if (target == NULL) {
        jniThrowException(env, "java/lang/IllegalStateException", "Binder has been finalized!");
        return JNI_FALSE;
    }

    LOGV("Java code calling transact on %p in Java object %p with code %d\n",
            target, obj, code);

    // Only log the binder call duration for things on the Java-level main thread.
    // But if we don't
    const bool time_binder_calls = should_time_binder_calls();

    int64_t start_millis;
    if (time_binder_calls) {
        start_millis = uptimeMillis();
    }
    //printf("Transact from Java code to %p sending: ", target); data->print();
    status_t err = target->transact(code, *data, reply, flags);
    //if (reply) printf("Transact from Java code to %p received: ", target); reply->print();
    if (time_binder_calls) {
        conditionally_log_binder_call(start_millis, target, code);
    }

    if (err == NO_ERROR) {
        return JNI_TRUE;
    } else if (err == UNKNOWN_TRANSACTION) {
        return JNI_FALSE;
    }

    signalExceptionForError(env, obj, err);
    return JNI_FALSE;
}


























typedef struct
{
     int volatile value;
} pthread_mutex_t;

class Mutex {
 public:
     enum {
         PRIVATE = 0,
         SHARED = 1
     };
     
                 Mutex();
                 Mutex(const char* name);
                 Mutex(int type, const char* name = NULL);
                 ~Mutex();
 
     // lock or unlock the mutex
     status_t    lock();
     void        unlock();
 
     // lock if possible; returns 0 on success, error otherwise
     status_t    tryLock();
 
     // Manages the mutex automatically. It'll be locked when Autolock is
     // constructed and released when Autolock goes out of scope.
     class Autolock {
     public:
         inline Autolock(Mutex& mutex) : mLock(mutex)  { mLock.lock(); }
         inline Autolock(Mutex* mutex) : mLock(*mutex) { mLock.lock(); }
         inline ~Autolock() { mLock.unlock(); }
     private:
         Mutex& mLock;
     };
 
 private:
     friend class Condition;
     
     // A mutex cannot be copied
                 Mutex(const Mutex&);
     Mutex&      operator = (const Mutex&);
     
 #if defined(HAVE_PTHREADS)
     pthread_mutex_t mMutex;
 #else
     void    _init();
     void*   mState;
 #endif
 };
 





class RefBase
{
protected:
    RefBase();
    virtual ~RefBase() {};
	virtual void onFirstRef() {};
	virtual void onLastStrongRef() {};
	virtual void onIncStrongAttempted() {};
	virtual void onLastWeakRef() {};

private:
    RefBase(const RefBase& o) { mRefs=NULL; };
    RefBase& operator=(const RefBase& o) { return *this; };

	void* mRefs;
};

template <typename T>
class sp
{
public:
    sp(T* other) { m_ptr=other; };

    sp(const sp<T>& other) { m_ptr=NULL; };
    template<typename U> sp(U* other) { m_ptr=NULL; };
    template<typename U> sp(const sp<U>& other) { m_ptr=NULL; };

    sp& operator = (T* other) { return *this; }
    sp& operator = (const sp<T>& other) { return *this; }

    template<typename U> sp& operator = (const sp<U>& other) { return *this; }
    template<typename U> sp& operator = (U* other) { return *this; }

    inline  T& operator* () const { return *m_ptr; }
    inline  T* operator-> () const { return m_ptr;  }
    inline  T* get() const { return m_ptr; }

private:
    template<typename Y> friend class sp;
    template<typename Y> friend class wp;
    T* m_ptr;
};

template <typename T>
class wp
{
public:
    wp(T* other) { m_ptr=NULL; m_refs=NULL; };
    wp(const wp<T>& other) { m_ptr=NULL; m_refs=NULL; };
    wp(const sp<T>& other) { m_ptr=NULL; m_refs=NULL; };
    template<typename U> wp(U* other) { m_ptr=NULL; m_refs=NULL; };
    template<typename U> wp(const sp<U>& other) { m_ptr=NULL; m_refs=NULL; };
    template<typename U> wp(const wp<U>& other) { m_ptr=NULL; m_refs=NULL; };

    wp& operator = (T* other) { return *this; }
    wp& operator = (const wp<T>& other) { return *this; }
    wp& operator = (const sp<T>& other) { return *this; }

    template<typename U> wp& operator = (U* other) { return *this; }
    template<typename U> wp& operator = (const wp<U>& other) { return *this; }
    template<typename U> wp& operator = (const sp<U>& other) { return *this; }

    template<typename U> inline bool operator != (const wp<U>& o) const { return true; }
    template<typename U> inline bool operator <= (const wp<U>& o) const { return true; }
    template<typename U> inline bool operator >= (const wp<U>& o) const { return true; }

    sp<T> promote() { return sp<T>(m_ptr); }

private:
    template<typename Y> friend class sp;
    template<typename Y> friend class wp;

    T* m_ptr;
    void* m_refs;
};

class IBinder : public virtual RefBase
{
public:
    virtual void queryLocalInterface() {};
    virtual void getInterfaceDescriptor() = 0;
    virtual void isBinderAlive() = 0;
    virtual void pingBinder() = 0;
    virtual void dump() = 0;
    virtual void transact() = 0;
    virtual void linkToDeath() = 0;
    virtual void unlinkToDeath() = 0;
    virtual void checkSubclass();
    virtual void attachObject() = 0;
    virtual void findObject() = 0;
    virtual void detachObject() = 0;
    virtual void localBinder() {};
    virtual void remoteBinder() {};
protected:
    virtual ~IBinder();
};

class BBinder : public IBinder
{
public:
    virtual void getInterfaceDescriptor() {};
    virtual void isBinderAlive() {};
    virtual void pingBinder() {};
    virtual void dump() {};
    virtual void transact() {};
    virtual void linkToDeath() {};
    virtual void unlinkToDeath() {};
    virtual void attachObject() {};
    virtual void findObject() {};
    virtual void detachObject() {};
    virtual void localBinder() {};

protected:
    virtual ~BBinder() {};
    virtual void onTransact() {};

private:
    BBinder(const BBinder& o) { mExtras=NULL; mReserved0=NULL; };
    BBinder& operator=(const BBinder& o) { return *this; };

	void* mExtras;
	void* mReserved0;
};

class JavaBBinder : public BBinder
{
public:
    jobject object() { return mObject; }

protected:
    virtual ~JavaBBinder() {};
    virtual void onTransact() {};
    virtual void dump() {};

private:
    void* mVM;
    jobject const mObject;
};

class JavaBBinderHolder : public RefBase
{
public:
	sp<IBinder> get() { return mBinder.promote(); }
private:
    void*           mLock;
    wp<JavaBBinder> mBinder;
};

0555 jobject javaObjectForIBinder(JNIEnv* env, const sp<IBinder>& val)
0556 {
0557     if (val == NULL) return NULL;
0558 
0559     if (val->checkSubclass(&gBinderOffsets)) {
0560         // One of our own!
0561         jobject object = static_cast<JavaBBinder*>(val.get())->object();
0562         LOGDEATH("objectForBinder %p: it's our own %p!\n", val.get(), object);
0563         return object;
0564     }
0565 
0566     // For the rest of the function we will hold this lock, to serialize
0567     // looking/creation of Java proxies for native Binder proxies.
0568     AutoMutex _l(mProxyLock);
0569 
0570     // Someone else's...  do we know about it?
0571     jobject object = (jobject)val->findObject(&gBinderProxyOffsets);
0572     if (object != NULL) {
0573         jobject res = env->CallObjectMethod(object, gWeakReferenceOffsets.mGet);
0574         if (res != NULL) {
0575             ALOGV("objectForBinder %p: found existing %p!\n", val.get(), res);
0576             return res;
0577         }
0578         LOGDEATH("Proxy object %p of IBinder %p no longer in working set!!!", object, val.get());
0579         android_atomic_dec(&gNumProxyRefs);
0580         val->detachObject(&gBinderProxyOffsets);
0581         env->DeleteGlobalRef(object);
0582     }
0583 
0584     object = env->NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);
0585     if (object != NULL) {
0586         LOGDEATH("objectForBinder %p: created new proxy %p !\n", val.get(), object);
0587         // The proxy holds a reference to the native object.
0588         env->SetIntField(object, gBinderProxyOffsets.mObject, (int)val.get());
0589         val->incStrong(object);
0590 
0591         // The native object needs to hold a weak reference back to the
0592         // proxy, so we can retrieve the same proxy if it is still active.
0593         jobject refObject = env->NewGlobalRef(
0594                 env->GetObjectField(object, gBinderProxyOffsets.mSelf));
0595         val->attachObject(&gBinderProxyOffsets, refObject,
0596                 jnienv_to_javavm(env), proxy_cleanup);
0597 
0598         // Also remember the death recipients registered on this proxy
0599         sp<DeathRecipientList> drl = new DeathRecipientList;
0600         drl->incStrong((void*)javaObjectForIBinder);
0601         env->SetIntField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast<jint>(drl.get()));
0602 
0603         // Note that a new object reference has been created.
0604         android_atomic_inc(&gNumProxyRefs);
0605         incRefsCreated(env);
0606     }
0607 
0608     return object;
0609 }
0610 
0611 sp<IBinder> ibinderForJavaObject(JNIEnv* env, jobject obj)
0612 {
0613     if (obj == NULL) return NULL;
0614 
0615     if (env->IsInstanceOf(obj, gBinderOffsets.mClass)) {
0616         JavaBBinderHolder* jbh = (JavaBBinderHolder*)
0617             env->GetIntField(obj, gBinderOffsets.mObject);
0618         return jbh != NULL ? jbh->get(env, obj) : NULL;
0619     }
0620 
0621     if (env->IsInstanceOf(obj, gBinderProxyOffsets.mClass)) {
0622         return (IBinder*)
0623             env->GetIntField(obj, gBinderProxyOffsets.mObject);
0624     }
0625 
0626     ALOGW("ibinderForJavaObject: %p is not a Binder object", obj);
0627     return NULL;
0628 }
0629 


 template <typename T>
 class sp
 {
 public:
     inline sp() : m_ptr(0) { }

     sp(T* other);
     sp(const sp<T>& other);
     template<typename U> sp(U* other);
     template<typename U> sp(const sp<U>& other);

     ~sp();

     // Assignment

     sp& operator = (T* other);
     sp& operator = (const sp<T>& other);

     template<typename U> sp& operator = (const sp<U>& other);
     template<typename U> sp& operator = (U* other);

     //! Special optimization for use by ProcessState (and nobody else).
     void force_set(T* other);

     // Reset

     void clear();

     // Accessors

     inline  T&      operator* () const  { return *m_ptr; }
     inline  T*      operator-> () const { return m_ptr;  }
     inline  T*      get() const         { return m_ptr; }

     // Operators

     COMPARE(==)
     COMPARE(!=)
     COMPARE(>)
     COMPARE(<)
     COMPARE(<=)
     COMPARE(>=)

 private:
     template<typename Y> friend class sp;
     template<typename Y> friend class wp;
     void set_pointer(T* ptr);
     T* m_ptr;
 };




template <typename T>
 class wp
 {
 public:
     typedef typename RefBase::weakref_type weakref_type;

     inline wp() : m_ptr(0) { }

     wp(T* other);
     wp(const wp<T>& other);
     wp(const sp<T>& other);
     template<typename U> wp(U* other);
     template<typename U> wp(const sp<U>& other);
     template<typename U> wp(const wp<U>& other);

     ~wp();

     // Assignment

     wp& operator = (T* other);
     wp& operator = (const wp<T>& other);
     wp& operator = (const sp<T>& other);

     template<typename U> wp& operator = (U* other);
     template<typename U> wp& operator = (const wp<U>& other);
     template<typename U> wp& operator = (const sp<U>& other);

     void set_object_and_refs(T* other, weakref_type* refs);

     // promotion to sp

     sp<T> promote() const;

     // Reset

     void clear();

     // Accessors

     inline  weakref_type* get_refs() const { return m_refs; }

     inline  T* unsafe_get() const { return m_ptr; }

     // Operators

     COMPARE_WEAK(==)
     COMPARE_WEAK(!=)
     COMPARE_WEAK(>)
     COMPARE_WEAK(<)
     COMPARE_WEAK(<=)
     COMPARE_WEAK(>=)

     inline bool operator == (const wp<T>& o) const {
         return (m_ptr == o.m_ptr) && (m_refs == o.m_refs);
     }
     template<typename U>
     inline bool operator == (const wp<U>& o) const {
         return m_ptr == o.m_ptr;
     }

     inline bool operator > (const wp<T>& o) const {
         return (m_ptr == o.m_ptr) ? (m_refs > o.m_refs) : (m_ptr > o.m_ptr);
     }
     template<typename U>
     inline bool operator > (const wp<U>& o) const {
         return (m_ptr == o.m_ptr) ? (m_refs > o.m_refs) : (m_ptr > o.m_ptr);
     }

     inline bool operator < (const wp<T>& o) const {
         return (m_ptr == o.m_ptr) ? (m_refs < o.m_refs) : (m_ptr < o.m_ptr);
     }
     template<typename U>
     inline bool operator < (const wp<U>& o) const {
         return (m_ptr == o.m_ptr) ? (m_refs < o.m_refs) : (m_ptr < o.m_ptr);
     }
                          inline bool operator != (const wp<T>& o) const { return m_refs != o.m_refs; }
     template<typename U> inline bool operator != (const wp<U>& o) const { return !operator == (o); }
                          inline bool operator <= (const wp<T>& o) const { return !operator > (o); }
     template<typename U> inline bool operator <= (const wp<U>& o) const { return !operator > (o); }
                          inline bool operator >= (const wp<T>& o) const { return !operator < (o); }
     template<typename U> inline bool operator >= (const wp<U>& o) const { return !operator < (o); }

 private:
     template<typename Y> friend class sp;
     template<typename Y> friend class wp;

     T*              m_ptr;
     weakref_type*   m_refs;
 };

class IBinder : public virtual RefBase
 {
 public:
     enum {
         FIRST_CALL_TRANSACTION  = 0x00000001,
         LAST_CALL_TRANSACTION   = 0x00ffffff,

         PING_TRANSACTION        = B_PACK_CHARS('_','P','N','G'),
         DUMP_TRANSACTION        = B_PACK_CHARS('_','D','M','P'),
         INTERFACE_TRANSACTION   = B_PACK_CHARS('_', 'N', 'T', 'F'),
         SYSPROPS_TRANSACTION    = B_PACK_CHARS('_', 'S', 'P', 'R'),

         // Corresponds to TF_ONE_WAY -- an asynchronous call.
         FLAG_ONEWAY             = 0x00000001
     };

                           IBinder();

     /**
      * Check if this IBinder implements the interface named by
      * @a descriptor.  If it does, the base pointer to it is returned,
      * which you can safely static_cast<> to the concrete C++ interface.
      */
     virtual sp<IInterface>  queryLocalInterface(const String16& descriptor);

     /**
      * Return the canonical name of the interface provided by this IBinder
      * object.
      */
     virtual const String16& getInterfaceDescriptor() const = 0;

     virtual bool            isBinderAlive() const = 0;
     virtual status_t        pingBinder() = 0;
     virtual status_t        dump(int fd, const Vector<String16>& args) = 0;

     virtual status_t        transact(   uint32_t code,
                                         const Parcel& data,
                                         Parcel* reply,
                                         uint32_t flags = 0) = 0;

     /**
      * This method allows you to add data that is transported through
      * IPC along with your IBinder pointer.  When implementing a Binder
      * object, override it to write your desired data in to @a outData.
      * You can then call getConstantData() on your IBinder to retrieve
      * that data, from any process.  You MUST return the number of bytes
      * written in to the parcel (including padding).
      */
     class DeathRecipient : public virtual RefBase
     {
     public:
         virtual void binderDied(const wp<IBinder>& who) = 0;
     };

     /**
      * Register the @a recipient for a notification if this binder
      * goes away.  If this binder object unexpectedly goes away
      * (typically because its hosting process has been killed),
      * then DeathRecipient::binderDied() will be called with a reference
      * to this.
      *
      * The @a cookie is optional -- if non-NULL, it should be a
      * memory address that you own (that is, you know it is unique).
      *
      * @note You will only receive death notifications for remote binders,
      * as local binders by definition can't die without you dying as well.
      * Trying to use this function on a local binder will result in an
      * INVALID_OPERATION code being returned and nothing happening.
      *
      * @note This link always holds a weak reference to its recipient.
      *
      * @note You will only receive a weak reference to the dead
      * binder.  You should not try to promote this to a strong reference.
      * (Nor should you need to, as there is nothing useful you can
      * directly do with it now that it has passed on.)
      */
     virtual status_t        linkToDeath(const sp<DeathRecipient>& recipient,
                                         void* cookie = NULL,
                                         uint32_t flags = 0) = 0;

     /**
      * Remove a previously registered death notification.
      * The @a recipient will no longer be called if this object
      * dies.  The @a cookie is optional.  If non-NULL, you can
      * supply a NULL @a recipient, and the recipient previously
      * added with that cookie will be unlinked.
      */
     virtual status_t        unlinkToDeath(  const wp<DeathRecipient>& recipient,
                                             void* cookie = NULL,
                                             uint32_t flags = 0,
                                             wp<DeathRecipient>* outRecipient = NULL) = 0;

     virtual bool            checkSubclass(const void* subclassID) const;

     typedef void (*object_cleanup_func)(const void* id, void* obj, void* cleanupCookie);

     virtual void            attachObject(   const void* objectID,
                                             void* object,
                                             void* cleanupCookie,
                                             object_cleanup_func func) = 0;
     virtual void*           findObject(const void* objectID) const = 0;
     virtual void            detachObject(const void* objectID) = 0;

     virtual BBinder*        localBinder();
     virtual BpBinder*       remoteBinder();

 protected:
     virtual          ~IBinder();

 private:
 };

class BBinder : public IBinder
{
public:
                        BBinder();

    virtual const String16& getInterfaceDescriptor() const;
    virtual bool        isBinderAlive() const;
    virtual status_t    pingBinder();
    virtual status_t    dump(int fd, const Vector<String16>& args);

    virtual status_t    transact(   uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);

    virtual status_t    linkToDeath(const sp<DeathRecipient>& recipient,
                                    void* cookie = NULL,
                                    uint32_t flags = 0);

    virtual status_t    unlinkToDeath(  const wp<DeathRecipient>& recipient,
                                        void* cookie = NULL,
                                        uint32_t flags = 0,
                                        wp<DeathRecipient>* outRecipient = NULL);

    virtual void        attachObject(   const void* objectID,
                                        void* object,
                                        void* cleanupCookie,
                                        object_cleanup_func func);
    virtual void*       findObject(const void* objectID) const;
    virtual void        detachObject(const void* objectID);

    virtual BBinder*    localBinder();

protected:
    virtual             ~BBinder();

    virtual status_t    onTransact( uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);

private:
                        BBinder(const BBinder& o);
            BBinder&    operator=(const BBinder& o);

    class Extras;

            Extras*     mExtras;
            void*       mReserved0;
};

class JavaBBinderHolder;

class JavaBBinder : public BBinder
{
public:
    JavaBBinder(JNIEnv* env, jobject object)
        : mVM(jnienv_to_javavm(env)), mObject(env->NewGlobalRef(object))
    {
        ALOGV("Creating JavaBBinder %p\n", this);
        android_atomic_inc(&gNumLocalRefs);
        incRefsCreated(env);
    }

    bool    checkSubclass(const void* subclassID) const
    {
        return subclassID == &gBinderOffsets;
    }

    jobject object() const
    {
        return mObject;
    }

protected:
    virtual ~JavaBBinder()
    {
        ALOGV("Destroying JavaBBinder %p\n", this);
        android_atomic_dec(&gNumLocalRefs);
        JNIEnv* env = javavm_to_jnienv(mVM);
        env->DeleteGlobalRef(mObject);
    }

    virtual status_t onTransact(
        uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags = 0)
    {
        JNIEnv* env = javavm_to_jnienv(mVM);

        ALOGV("onTransact() on %p calling object %p in env %p vm %p\n", this, mObject, env, mVM);

        IPCThreadState* thread_state = IPCThreadState::self();
        const int strict_policy_before = thread_state->getStrictModePolicy();
        thread_state->setLastTransactionBinderFlags(flags);

        //printf("Transact from %p to Java code sending: ", this);
        //data.print();
        //printf("\n");
        jboolean res = env->CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,
            code, (int32_t)&data, (int32_t)reply, flags);
        jthrowable excep = env->ExceptionOccurred();

        if (excep) {
            report_exception(env, excep,
                "*** Uncaught remote exception!  "
                "(Exceptions are not yet supported across processes.)");
            res = JNI_FALSE;

            /* clean up JNI local ref -- we don't return to Java code */
            env->DeleteLocalRef(excep);
        }

        // Restore the Java binder thread's state if it changed while
        // processing a call (as it would if the Parcel's header had a
        // new policy mask and Parcel.enforceInterface() changed
        // it...)
        const int strict_policy_after = thread_state->getStrictModePolicy();
        if (strict_policy_after != strict_policy_before) {
            // Our thread-local...
            thread_state->setStrictModePolicy(strict_policy_before);
            // And the Java-level thread-local...
            set_dalvik_blockguard_policy(env, strict_policy_before);
        }

        jthrowable excep2 = env->ExceptionOccurred();
        if (excep2) {
            report_exception(env, excep2,
                "*** Uncaught exception in onBinderStrictModePolicyChange");
            /* clean up JNI local ref -- we don't return to Java code */
            env->DeleteLocalRef(excep2);
        }

        // Need to always call through the native implementation of
        // SYSPROPS_TRANSACTION.
        if (code == SYSPROPS_TRANSACTION) {
            BBinder::onTransact(code, data, reply, flags);
        }

        //aout << "onTransact to Java code; result=" << res << endl
        //    << "Transact from " << this << " to Java code returning "
        //    << reply << ": " << *reply << endl;
        return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;
    }

    virtual status_t dump(int fd, const Vector<String16>& args)
    {
        return 0;
    }

private:
    JavaVM* const   mVM;
    jobject const   mObject;
};

class JavaBBinderHolder : public RefBase
{
public:
    sp<JavaBBinder> get(JNIEnv* env, jobject obj)
    {
        AutoMutex _l(mLock);
        sp<JavaBBinder> b = mBinder.promote();
        if (b == NULL) {
            b = new JavaBBinder(env, obj);
            mBinder = b;
            ALOGV("Creating JavaBinder %p (refs %p) for Object %p, weakCount=%d\n",
                 b.get(), b->getWeakRefs(), obj, b->getWeakRefs()->getWeakCount());
        }

        return b;
    }

    sp<JavaBBinder> getExisting()
    {
        AutoMutex _l(mLock);
        return mBinder.promote();
    }

private:
    Mutex           mLock;
    wp<JavaBBinder> mBinder;
};

class RefBase
 {
 public:
             void            incStrong(const void* id) const;
             void            decStrong(const void* id) const;

             void            forceIncStrong(const void* id) const;

             //! DEBUGGING ONLY: Get current strong ref count.
             int32_t         getStrongCount() const;

     class weakref_type
     {
     public:
         RefBase*            refBase() const;

         void                incWeak(const void* id);
         void                decWeak(const void* id);

         // acquires a strong reference if there is already one.
         bool                attemptIncStrong(const void* id);

         // acquires a weak reference if there is already one.
         // This is not always safe. see ProcessState.cpp and BpBinder.cpp
         // for proper use.
         bool                attemptIncWeak(const void* id);

         //! DEBUGGING ONLY: Get current weak ref count.
         int32_t             getWeakCount() const;

         //! DEBUGGING ONLY: Print references held on object.
         void                printRefs() const;

         //! DEBUGGING ONLY: Enable tracking for this object.
         // enable -- enable/disable tracking
         // retain -- when tracking is enable, if true, then we save a stack trace
         //           for each reference and dereference; when retain == false, we
         //           match up references and dereferences and keep only the
         //           outstanding ones.

         void                trackMe(bool enable, bool retain);
     };

             weakref_type*   createWeak(const void* id) const;

             weakref_type*   getWeakRefs() const;

             //! DEBUGGING ONLY: Print references held on object.
     inline  void            printRefs() const { getWeakRefs()->printRefs(); }

             //! DEBUGGING ONLY: Enable tracking of object.
     inline  void            trackMe(bool enable, bool retain)
     {
         getWeakRefs()->trackMe(enable, retain);
     }

     typedef RefBase basetype;

 protected:
                             RefBase();
     virtual                 ~RefBase();

     //! Flags for extendObjectLifetime()
     enum {
         OBJECT_LIFETIME_STRONG  = 0x0000,
         OBJECT_LIFETIME_WEAK    = 0x0001,
         OBJECT_LIFETIME_MASK    = 0x0001
     };

             void            extendObjectLifetime(int32_t mode);

     //! Flags for onIncStrongAttempted()
     enum {
         FIRST_INC_STRONG = 0x0001
     };

     virtual void            onFirstRef();
     virtual void            onLastStrongRef(const void* id);
     virtual bool            onIncStrongAttempted(uint32_t flags, const void* id);
     virtual void            onLastWeakRef(const void* id);

 private:
     friend class ReferenceMover;
     static void moveReferences(void* d, void const* s, size_t n,
             const ReferenceConverterBase& caster);

 private:
     friend class weakref_type;
     class weakref_impl;

                             RefBase(const RefBase& o);
             RefBase&        operator=(const RefBase& o);

         weakref_impl* const mRefs;
 };
}
