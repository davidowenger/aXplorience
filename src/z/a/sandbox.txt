

ServiceManager -> get bluetooth
ServiceManager -> get bluetootha2p ?? -> proxy
		-> native
		ba2p.cpp ?







handle -> proxy !

const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);

void acquire_object(const sp<ProcessState>& proc,
    const flat_binder_object& obj, const void* who)
{
    switch (obj.type) {
        case BINDER_TYPE_BINDER:
            if (obj.binder) {
                LOG_REFS("Parcel %p acquiring reference on local %p", who, obj.cookie);
                static_cast<IBinder*>(obj.cookie)->incStrong(who);
            }
            return;
        case BINDER_TYPE_HANDLE: {
            const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);
            if (b != NULL) {
                LOG_REFS("Parcel %p acquiring reference on remote %p", who, b.get());
                b->incStrong(who);
            }
            return;




















		mNewService = new BluetoothService(w.context);

		try {
			Method m = mNewService.getClass().getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, boolean.class});
			m.setAccessible(true);
			m.invoke(mNewService, new Object[] {"Pairable", true});
			m.invoke(mNewService, new Object[] {"Discoverable", true});
		} catch (Exception e) {
			//System.out.println(e.getMessage());
			e.printStackTrace();
		}























		try {
			Field f_internal = Class.forName("android.bluetooth.BluetoothAdapter").getDeclaredField("SCAN_MODE_CONNECTABLE");
			f_internal.setAccessible(true);
			f_internal.set(null, 23);
			f_internal = Class.forName("android.bluetooth.BluetoothAdapter").getDeclaredField("SCAN_MODE_NONE");
			f_internal.setAccessible(true);
			f_internal.set(null, 23);
		} catch (Exception e) {
			e.printStackTrace();
		}

		try {
			Class m[] = Class.forName("android.Manifest").getDeclaredClasses();
			Class p = m[1];

			Field f_internal = p.getDeclaredField("MODIFY_AUDIO_SETTINGS");
			f_internal.setAccessible(true);
			f_internal.set(null, "android.permission.WRITE_SECURE_SETTINGS");

			Field f_internal2 = p.getDeclaredField("WRITE_SECURE_SETTINGS");
			f_internal2.setAccessible(true);
			f_internal2.set(null, "android.permission.MODIFY_AUDIO_SETTINGS");

			Field f_internal_service = blueAdapter.getClass().getDeclaredField("mService");
	    	f_internal_service.setAccessible(true);
	    	mBluetoothService = f_internal_service.get(blueAdapter);

	    	Method m_add_rfcomm_service_record = mBluetoothService.getClass().getDeclaredMethod("setScanMode", new Class[] {int.class, int.class});
	    	m_add_rfcomm_service_record.setAccessible(true);
	    	m_add_rfcomm_service_record.invoke(mBluetoothService, new Object[] {BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE,0});
		} catch (Exception e) {
			e.printStackTrace();
		}

        HashMap<String, IBinder> thesCache = new HashMap<String, IBinder>();

	    try {
	        final Class serviceManager = Class.forName("android.os.ServiceManager");
			Field fsCache = serviceManager.getDeclaredField("sCache");
			fsCache.setAccessible(true);
			HashMap<String, IBinder> sCache = (HashMap<String, IBinder>)fsCache.get(null);
			thesCache = sCache;
	    } catch (final Exception e) {
			e.printStackTrace();
	    }

        String[] thelist;

	    try {
	        final Class serviceManager = Class.forName("android.os.ServiceManager");
	        final Method listServices = serviceManager.getDeclaredMethod("listServices", new Class[] {});
	        String[] list = (String[]) listServices.invoke(null, new Object[] {});
	        thelist = list;
	    } catch (final Exception e) {
			e.printStackTrace();
	    }

        IInterface iface = null;
	    try {
	        final Class serviceManager = Class.forName("android.os.ServiceManager");


	        final Method getService = serviceManager.getDeclaredMethod("getService", String.class);
	        final IBinder iBinder = (IBinder) getService.invoke(null, "bluetooth_a2dp");

	        iface = iBinder.queryLocalInterface("android.bluetooth.IBluetoothA2dp");
	    } catch (final Exception e) {
			e.printStackTrace();
	    }

	    try {
	        final Class serviceManager = Class.forName("android.os.ServiceManager");
	        final Method getService = serviceManager.getDeclaredMethod("getService", String.class);
	        final IBinder iBinder = (IBinder) getService.invoke(null, "bluetooth_a2dp");
	        final Class iBluetoothA2dp = Class.forName("android.bluetooth.IBluetoothA2dp");
	        final Class[] declaredClasses = iBluetoothA2dp.getDeclaredClasses();
	        final Class c = declaredClasses[0];
	        final Method asInterface = c.getDeclaredMethod("asInterface", IBinder.class);
	        asInterface.setAccessible(true);
	        Object ibta = asInterface.invoke(null, iBinder);
	        Class cBluetoothA2dpService = Class.forName("android.server.BluetoothA2dpService");
			Field fBluetoothService = cBluetoothA2dpService.getDeclaredField("mBluetoothService");
			fBluetoothService.setAccessible(true);
			mBluetoothService = fBluetoothService.get(cBluetoothA2dpService.cast(ibta));
	    } catch (final Exception e) {
			e.printStackTrace();
	    }

	    try {
	        final Class serviceManager = Class.forName("android.os.ServiceManager");
	        final Method getService = serviceManager.getDeclaredMethod("getService", String.class);
	        final IBinder iBinder = (IBinder) getService.invoke(null, "bluetooth_a2dp");
	        final Class iBluetoothA2dp = Class.forName("android.bluetooth.IBluetoothA2dp");
	        final Class[] declaredClasses = iBluetoothA2dp.getDeclaredClasses();
	        final Class c = declaredClasses[0];
	        final Method asInterface = c.getDeclaredMethod("asInterface", IBinder.class);
	        asInterface.setAccessible(true);
	        Object ibta = asInterface.invoke(null, iBinder);
	        Class cBluetoothA2dpService = Class.forName("android.server.BluetoothA2dpService");
			Field fBluetoothService = cBluetoothA2dpService.getDeclaredField("mBluetoothService");
			fBluetoothService.setAccessible(true);
			mBluetoothService = fBluetoothService.get(ibta);
	    } catch (final Exception e) {
			e.printStackTrace();
	    }

		try {
			Field f_internal_service = blueAdapter.getClass().getDeclaredField("mService");
	    	f_internal_service.setAccessible(true);
			Object service = f_internal_service.get(blueAdapter);

			Field fRemote = service.getClass().getDeclaredField("mRemote");
			fRemote.setAccessible(true);
			Object binder = fRemote.get(service);

	    	Class<?> p = binder.getClass();
	    	Class[] tabc = p.getDeclaredClasses();
	    	Constructor[] tabd = p.getDeclaredConstructors();
	    	Field[] tabe = p.getDeclaredFields();
	    	Method[] tabf = p.getDeclaredMethods();
	    	Class tabg = p.getEnclosingClass();

			Method id = p.getDeclaredMethod("getInterfaceDescriptor", new Class[] {});
			id.setAccessible(true);
			String str = (String)id.invoke(binder, new Object[] {});

			Method q = p.getDeclaredMethod("queryLocalInterface", new Class[] {String.class});
			q.setAccessible(true);
			Object iface = q.invoke(binder, new Object[] {str});

			Field fDesc = binder.getClass().getDeclaredField("mSelf");
			fDesc.setAccessible(true);
			Object desc = fDesc.get(binder);

			Method m = Class.forName("android.server.BluetoothService").getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, boolean.class});
			m.setAccessible(true);
			m.invoke(binder, new Object[] {"Pairable", true});
			m.invoke(binder, new Object[] {"Discoverable", true});
		} catch (Exception e) {
			e.printStackTrace();
		}

		
		try {

			Class ibt = Class.forName("android.bluetooth.IBluetooth");
			Method asInterface = ibt.getDeclaredMethod("asInterface", new Class[] {String.class, boolean.class});

			Field f_internal_service = blueAdapter.getClass().getDeclaredField("mService");
	    	f_internal_service.setAccessible(true);
			Object service = f_internal_service.get(blueAdapter);

			Method m = Class.forName("android.server.BluetoothService").getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, boolean.class});
			m.setAccessible(true);
			m.invoke(Class.forName("android.server.BluetoothService").cast(binder), new Object[] {"Pairable", true});
			m.invoke(Class.forName("android.server.BluetoothService").cast(binder), new Object[] {"Discoverable", true});
		} catch (Exception e) {
			e.printStackTrace();
		}

		public interface IBluetooth extends android.os.IInterface
		{
			public static class Stub extends android.os.Binder implements IBluetooth
			{
				public static android.bluetooth.IBluetooth asInterface(android.os.IBinder obj)
				{
				    return (android.bluetooth.IBluetooth)obj.queryLocalInterface(DESCRIPTOR);
				}
				
				private static class Proxy implements IBluetooth
				{
				}
			}
		}
		IBluetooth mService = new IBluetooth.Stub.Proxy();

			//Class cDesc = desc.getClass().asSubclass(fDesc.getType());
			//desc = cDesc.cast(desc);
			//HttpRoute route = desc.getRoute();
			//BasicPoolEntry entry = desc.get();

			if (route != null) {
				System.out.println(route.toString());
			}
			if (route != null) {
				System.out.println(entry.toString());
			}

        if (w.cAPI >= VERSION_CODES.JELLY_BEAN_MR2) {
        	blueManager = (BluetoothManager)getSystemService(BLUETOOTH_SERVICE);
        }

        String msg = "";

		try {
	    	Class<?> s = Class.forName("android.server.BluetoothService extends android.server.IBluetooth.Stub");
		} catch (Exception e) {
			//System.out.println(e.getMessage());
			e.printStackTrace();
		}

		try {
			Field f_internal_service = blueAdapter.getClass().getDeclaredField("mService");
	    	f_internal_service.setAccessible(true);

	    	Class<?> i = Class.forName("android.bluetooth.IBluetooth");
	    	Class<?> t = Class.forName("android.bluetooth.IBluetooth$Stub");
	    	Class<?> p = Class.forName("android.bluetooth.IBluetooth$Stub$Proxy");
	    	Class<?> s = Class.forName("android.server.BluetoothService");

	    	Class[] tabc = p.getDeclaredClasses();
	    	Constructor[] tabd = p.getDeclaredConstructors();
	    	Field[] tabe = p.getDeclaredFields();
	    	Method[] tabf = p.getDeclaredMethods();
	    	Class tabg = p.getEnclosingClass();

	    	Class<?> pi = p.asSubclass(i);
	    	Class<?> si = s.asSubclass(i);
	    	Class<?> st = s.asSubclass(t);

	    	Object a = f_internal_service.get(blueAdapter);
	    	Object b = i.cast(a);
	    	Object c = pi.cast(b);

			Method m = si.getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, boolean.class});
			m.setAccessible(true);

			m.invoke(st.cast(f_internal_service.get(blueAdapter)), "Pairable", true);
		} catch (Exception e) {
			//System.out.println(e.getMessage());
			e.printStackTrace();
		}

		try {
			Field f_internal_service = blueAdapter.getClass().getDeclaredField("mService");
	    	f_internal_service.setAccessible(true);

	    	Class<?> i = Class.forName("android.bluetooth.IBluetooth");
	    	Class<?> p = Class.forName("android.bluetooth.IBluetooth$Stub$Proxy");
	    	Class<?> s = Class.forName("android.server.BluetoothService");

	    	Class pi = p.asSubclass(i);
	    	Class si = s.asSubclass(i);

	    	Object a = f_internal_service.get(blueAdapter);
	    	Object b = i.cast(a);
	    	Object c = si.cast(b);

			Method m = si.getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, boolean.class});
			m.setAccessible(true);

			m.invoke(c, "Pairable", true);
		} catch (Exception e) {
			//System.out.println(e.getMessage());
			e.printStackTrace();
		}

		try {
			Field f_internal_service = blueAdapter.getClass().getDeclaredField("mService");
	    	f_internal_service.setAccessible(true);

	    	int index = 0;

			Class sa = null;
			Class sb = null;
			Class sc = null;
			Class ia = null;

			Class ssb = null;
			Class sasc = null;
			Class sbsc = null;
			Class sia = null;

			try {
				sa = Class.forName("android.bluetooth.IBluetooth");
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				sb = Class.forName("android.bluetooth.IBluetooth$Stub");
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				sc = Class.forName("android.server.BluetoothService");
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				ia = f_internal_service.get(blueAdapter).getClass(); //android.bluetooth.IBluetooth$Stub$Proxy
			} catch (Exception e) {
				e.printStackTrace();
			}
			index++;

			Type tg = f_internal_service.getGenericType();
			Class<? extends Field> tc = f_internal_service.getClass();
			Class<?> td = f_internal_service.getDeclaringClass();
			Class<?> tt = f_internal_service.getType();
			Type ttst = f_internal_service.getType().getGenericSuperclass();

			//Type psc = sc.getClass().getGenericSuperclass();
			//Type tsc = ((ParameterizedType)psc).getActualTypeArguments()[0];

			Method m = sc.getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, boolean.class});
			m.setAccessible(true);

			index++;

			try {
				//ssa = sa.asSubclass(ia);
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//ssa = sa.asSubclass(sb);
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//ssa = sa.asSubclass(sc);
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//ssb = sb.asSubclass(ia);
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				ssb = sb.asSubclass(sa); // stub extends IBlue
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//ssb = sb.asSubclass(sc);
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//ssc = sc.asSubclass(ia);
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				sasc = sc.asSubclass(sa); // service extends IBlue
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				sbsc = sc.asSubclass(sb); // service extends stub
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				sia = ia.asSubclass(sa); // proxy extends IBlue
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//sia = ia.asSubclass(sb);
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//sia = ia.asSubclass(sc);
			} catch (Exception e) {
				e.printStackTrace();
			}

			index++;

			try {
				sa.cast(f_internal_service.get(blueAdapter));
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//sb.cast(f_internal_service.get(blueAdapter));
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//sc.cast(f_internal_service.get(blueAdapter));
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				ia.cast(f_internal_service.get(blueAdapter));
			} catch (Exception e) {
				e.printStackTrace();
			}

			index++;

			try {
				//Object ossb = ssb.cast(f_internal_service.get(blueAdapter));
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//Object osasc = sasc.cast(f_internal_service.get(blueAdapter));
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				//Object osbsc = sbsc.cast(f_internal_service.get(blueAdapter));
			} catch (Exception e) {
				e.printStackTrace();
			}
			try {
				Object osia = sia.cast(f_internal_service.get(blueAdapter)); // proxy extends IBlue
			} catch (Exception e) {
				e.printStackTrace();
			}


	    	//mBluetoothService = f_internal_service.get(blueAdapter);
	    	//Class<? extends Object> d = mBluetoothService.getClass();
	    	//Class<? extends Object> c = Class.forName("android.server.BluetoothService").asSubclass(f_internal_service.get(blueAdapter).getClass());

			//Class<?> cbs = Class.forName("android.server.BluetoothService");
			//Type tbs = (Type)Class.forName("android.server.BluetoothService");
			//Class<? extends Type> instance = ((Type)Class.forName("android.server.BluetoothService")).getClass();

			//ia.cast(f_internal_service.get(blueAdapter));
			m.invoke(sia.cast(f_internal_service.get(blueAdapter)), "Pairable", true);
			//m.invoke(f_internal_service.get(blueAdapter), "Pairable", true);
			//m.invoke(c.cast(mBluetoothService), "Discoverable", true);

		} catch (Exception e) {
			//System.out.println();
			msg = e.getMessage();
			e.printStackTrace();
		}


android.bluetooth.IBluetooth$Stub$Proxy








    	// Demande à l'utilisateur l'autorisation pour rendre visible le terminal
    	Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
    	discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 120); // Cette ligne permet de définir une durée de visibilité de notre choix
    	startActivityForResult(discoverableIntent, REQUEST_DISCOVERABLE_BT);

	    	Method m_add_rfcomm_service_record = mBluetoothService.getClass().getDeclaredMethod("setScanMode", new Class[] {int.class, int.class});
	    	m_add_rfcomm_service_record.setAccessible(true);
	    	m_add_rfcomm_service_record.invoke(mBluetoothService, new Object[] {blueAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE,120});

	protected void onActivityResult(int cRequest, int cResult, Intent data)
    {
		if (cRequest == REQUEST_ENABLE_BT) {
			if (cResult == RESULT_OK) {
				System.out.println("REQUEST_ENABLE_BT");
			}
		}
		if (cRequest == REQUEST_DISCOVERABLE_BT) {
			if (cResult != RESULT_CANCELED) {
				//  result code equal to the duration that the device is discoverable
				System.out.println("REQUEST_DISCOVERABLE_BT");
				System.out.println("REQUEST_DISCOVERABLE_BT duration: #" + cResult);
			}
		}
    }

		try {
	    	Method m_add_rfcomm_service_record = mBluetoothService.getClass().getDeclaredMethod("setScanMode", new Class[] {int.class, int.class});
	    	m_add_rfcomm_service_record.setAccessible(true);
	    	m_add_rfcomm_service_record.invoke(mBluetoothService, new Object[] {blueAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE,0});
		} catch (Exception e) {
			//System.out.println(e.getMessage());
			e.printStackTrace();
		}

	    	
			Class[] acIBluetooth = mBluetoothService.getClass().getDeclaredClasses();
			Class cIBluetoothStub = null;
			
			
			for (Class cIBluetoothChild : acIBluetooth) {
				if(cIBluetoothChild.getCanonicalName().equals(mBluetoothService.getClass().getName() + ".Stub")) {
					cIBluetoothStub = cIBluetoothChild;
					break;
				}
			}
	    	Method m_add_rfcomm_service_record = cIBluetoothStub.getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, Boolean.class});
	    	m_add_rfcomm_service_record.setAccessible(true);
	    	m_add_rfcomm_service_record.invoke(mBluetoothService, new Object[] {"Pairable", true});
	    	m_add_rfcomm_service_record.invoke(mBluetoothService, new Object[] {"Discoverable", true});
	    	
	    	
	    	
	    	
	    	
	    	
	    	

http://stackoverflow.com/questions/14705167/how-connect-paired-bluetooth-a2dp-device-on-android-4-2-using-reflection/16003953#16003953
	
Finally got this working on 4.2. See the details here: http://code.google.com/p/a2dp-connect2/

It is quite different from 4.1 and before.

First call connect to the interface like this:

    public static void getIBluetoothA2dp(Context context) {

    Intent i = new Intent(IBluetoothA2dp.class.getName());

    if (context.bindService(i, mConnection, Context.BIND_AUTO_CREATE)) {

    } else {
        // Log.e(TAG, "Could not bind to Bluetooth A2DP Service");
    }

}
When the interface is returned it will call back to this:

    public static ServiceConnection mConnection = new ServiceConnection() {

    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {

        ibta2 = IBluetoothA2dp.Stub.asInterface(service);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        // TODO Auto-generated method stub

    }

};












			Class cIBluetoothStub = Class.forName("android.bluetooth.IBluetooth.Stub");
	    	Method m_add_rfcomm_service_record = cIBluetoothStub.getDeclaredMethod("setPropertyBoolean", new Class[] {String.class, Boolean.class});
	    	m_add_rfcomm_service_record.setAccessible(true);
	    	m_add_rfcomm_service_record.invoke(mBluetoothService, new Object[] {"Pairable", true});
	    	m_add_rfcomm_service_record.invoke(mBluetoothService, new Object[] {"Discoverable", true});


        // Vérification de la présence du Bluetooth sur le terminal
        if (w.cAPI <= VERSION_CODES.JELLY_BEAN_MR1) {
            blueAdapter = BluetoothAdapter.getDefaultAdapter();
        } else {
        	blueAdapter = (BluetoothAdapter)getSystemService(BLUETOOTH_SERVICE);
        }
        if (blueAdapter == null) {
            // Le terminal ne possède pas le Bluetooth
        }

        if (!blueAdapter.isEnabled()) {
    		try {
    			Field f_internal_service = adapter.getClass().getDeclaredField("mService");
	    	f_internal_service.setAccessible(true);
	    	Object internal_service = f_internal_service.get(adapter);
	    	
	    	Method m_add_rfcomm_service_record = internal_service.getClass().getDeclaredMethod("addRfcommServiceRecord", new Class[] {String.class, ParcelUuid.class, int.class, IBinder.class});
	    	m_add_rfcomm_service_record.setAccessible(true);
	
    			Class cServiceManager = Class.forName("android.os.ServiceManager");
    			Method mGetService = cServiceManager.getDeclaredMethod("getService", String.class);
    			IBinder iBinder = (IBinder)mGetService.invoke(null, "bluetooth");
    			Class cIBluetooth = Class.forName("android.bluetooth.IBluetooth");
    			Class[] acIBluetooth = cIBluetooth.getDeclaredClasses();
    			Class iBluetooth = acIBluetooth[0];
    			Method mAsInterface = iBluetooth.getDeclaredMethod("asInterface", IBinder.class);
    			mAsInterface.setAccessible(true);
    			oIBluetooth = mAsInterface.invoke(null, iBinder);

    			Class cBluetoothService = Class.forName("android.server.BluetoothService");
    			Method mEnable = cBluetoothService.getDeclaredMethod("enable", new Class[] {Boolean.class});

    			mEnable.invoke(oIBluetooth, true);
    		} catch (Exception e) {
    			System.out.println(e.getMessage());
    			e.printStackTrace();
    		}
        }
		try {
			Class cBluetoothService = Class.forName("android.server.BluetoothService");
			Method mSsetAdapterPropertyBooleanNative = cBluetoothService.getDeclaredMethod("setAdapterPropertyBooleanNative", String.class, Boolean.class);

			mSsetAdapterPropertyBooleanNative.invoke(oIBluetooth, "Pairable", true);
			mSsetAdapterPropertyBooleanNative.invoke(oIBluetooth, "Discoverable", true);
		} catch (Exception e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		}


package z.a;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.util.Set;
import java.util.UUID;

import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothServerSocket;
import android.bluetooth.BluetoothSocket;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build.VERSION_CODES;
import android.os.Bundle;
import android.os.IBinder;

public class TApp extends Activity
{
	public static final int REQUEST_ENABLE_BT = 1;
	public static final int REQUEST_DISCOVERABLE_BT = REQUEST_ENABLE_BT + 1;

	public TWrapper w;
	public long n;
	public boolean debug = false;
	public Set<String> mArrayAdapter;
	public BluetoothAdapter blueAdapter;
	public String mServiceName = "Proximity service";
	public UUID mUUID = new UUID(2001L,2000L);

	// On crée un BroadcastReceiver pour ACTION_FOUND
	private final BroadcastReceiver receiver = new BroadcastReceiver() {
	    public void onReceive(Context context, Intent intent) {
	        String action = intent.getAction();
	        // Quand la recherche trouve un terminal
	        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
	            // On récupère l'object BluetoothDevice depuis l'Intent
	            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
				// On ajoute le nom et l'adresse du périphérique dans un ArrayAdapter (par exemple pour l'afficher dans une ListView)
	            mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
	        }
	    }
	};
	//"ACTION_STATE_CHANGED" pour savoir quand l'état du Bluetooth change. Vous pourrez alors utiliser "EXTRA_STATE" et "EXTRA_PREVIOUS_STATE" pour connaître l'état courant et l'état antérieur du Bluetooth. Les valeurs possibles sont "STATE_TURNING_ON", "STATE_ON", "STATE_TURNING_OFF" et "STATE_OFF".
	private final BroadcastReceiver stateChange =  new BroadcastReceiver() {
	    public void onReceive(Context context, Intent intent) {
	        String action = intent.getAction();
	        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)) {
	        	int parcelable = intent.getParcelableExtra(BluetoothAdapter.EXTRA_STATE);
	        	int parcelable2 = intent.getParcelableExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE);
	        	//"STATE_TURNING_ON", "STATE_ON", "STATE_TURNING_OFF" et "STATE_OFF"
	        }
	   }
	};

	//"ACTION_SCAN_MODE_CHANGED". Les champs "EXTRA_SCAN_MODE" et "EXTRA_PREVIOUS_SCAN_MODE" vous donneront les informations sur l'état précédent et actuel de la visibilité du périphérique. Les valeurs possibles sont "SCAN_MODE_CONNECTABLE_DISCOVERABLE", "SCAN_MODE_CONNECTABLE", ou "SCAN_MODE_NONE".
	private final BroadcastReceiver modeChange =  new BroadcastReceiver() {
	    public void onReceive(Context context, Intent intent) {
	        String action = intent.getAction();
	        if (BluetoothAdapter.ACTION_SCAN_MODE_CHANGED.equals(action)) {
	        	int parcelable = intent.getParcelableExtra(BluetoothAdapter.EXTRA_SCAN_MODE);
	        	int parcelable2 = intent.getParcelableExtra(BluetoothAdapter.EXTRA_PREVIOUS_SCAN_MODE);
	            //"SCAN_MODE_CONNECTABLE_DISCOVERABLE", "SCAN_MODE_CONNECTABLE", ou "SCAN_MODE_NONE"
	        }
	   }
	};

	// Called when the activity is first created
	protected void onCreate(Bundle savedInstanceState)
    {
		// Debug
        if (debug) {
			try {
				Thread.sleep(10000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
        }

        // Init
        w = new TWrapper();
        w.tApp = this;
        w.context = getApplication();
        w.tFrame = new TClozer(w);
        w.tFrame.tInit();

        //Todo
        super.onCreate(savedInstanceState);

        // Call user onCreate event
        w.tVisitorApp.nRun(w.omicron);

        
        /*
        // Vérification de la présence du Bluetooth sur le terminal
        if (w.cAPI <= VERSION_CODES.JELLY_BEAN_MR1) {
            blueAdapter = BluetoothAdapter.getDefaultAdapter();
        } else {
        	blueAdapter = (BluetoothAdapter)getSystemService(BLUETOOTH_SERVICE);
        }
        if (blueAdapter == null) {
            // Le terminal ne possède pas le Bluetooth
        }

        // If Bluetooth has not been enabled on the device, then
        // enabling device discoverability will automatically enable Bluetooth.
        if (!blueAdapter.isEnabled()) {
            Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
        }

        // Récupération des ériphériques connus
        Set<BluetoothDevice> pairedDevices = blueAdapter.getBondedDevices();

		// If there are paired devices
		if (pairedDevices.size() > 0) {
		    // Loop through paired devices
		    for (BluetoothDevice device : pairedDevices) {
		        // Add the name and address to an array adapter to show in a ListView
		        mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
		    }
		}

    	// Inscrire le BroadcastReceiver
    	IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
    	registerReceiver(receiver, filter); // N'oubliez pas de le désinscrire lors du OnDestroy() !

    	// Requires BLUETOOTH_ADMIN.
    	blueAdapter.startDiscovery();

    	int timeVisible = 300;


    	// Demande à l'utilisateur l'autorisation pour rendre visible le terminal


    	Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
    	discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, timeVisible); // Cette ligne permet de définir une durée de visibilité de notre choix
    	startActivityForResult(discoverableIntent, REQUEST_DISCOVERABLE_BT);
        */


    	/*
    	BluetoothService blueService;
        blueService.mHandler.removeMessages(MESSAGE_DISCOVERABLE_TIMEOUT);
    	*/
        
		try {


			Class cServiceManager = Class.forName("android.os.ServiceManager");
			Method mGetService = cServiceManager.getDeclaredMethod("getService", String.class);
			IBinder iBinder = (IBinder)mGetService.invoke(null, "bluetooth");
			Class cIBluetooth = Class.forName("android.bluetooth.IBluetooth");
			Class[] acIBluetooth = cIBluetooth.getDeclaredClasses();
			Class iBluetooth = acIBluetooth[0];
			Method mAsInterface = iBluetooth.getDeclaredMethod("asInterface", IBinder.class);
			mAsInterface.setAccessible(true);
			oIBluetooth = mAsInterface.invoke(null, b);

			Class cBluetoothService = Class.forName("android.server.BluetoothService");
			Method mSsetAdapterPropertyBooleanNative = cBluetoothService.getDeclaredMethod("setAdapterPropertyBooleanNative", String.class, Boolean.class);

			mSsetAdapterPropertyBooleanNative.invoke(oIBluetooth, "Pairable", true);
			mSsetAdapterPropertyBooleanNative.invoke(oIBluetooth, "Discoverable", true);


		} catch (Exception e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		}



			Class cIBluetooth = Class.forName("android.bluetooth.IBluetooth");
			Class[] acIBluetooth = cIBluetooth.getDeclaredClasses();
			Class cBluetoothService = acIBluetooth[0];





			Class cServiceManager = Class.forName("android.os.ServiceManager");
			Method mGetService = cServiceManager.getDeclaredMethod("getService",String.class);
		  //IBinder oBluetoothService = (IBinder) mGetService.invoke(null, "bluetooth");

			Object oBluetoothService = mGetService.invoke(null, "bluetooth");
			Method mSetPropertyBoolean = cServiceManager.getDeclaredMethod("getService",String.class);
	        blueService.setPropertyBoolean("Discoverable", discoverable);

			Class c3 = Class.forName("android.bluetooth.IBluetooth");

			Class[] s2 = c3.getDeclaredClasses();

			Class c = s2[0];
			Method m = c.getDeclaredMethod("asInterface",IBinder.class);
			m.setAccessible(true);
			ibt = (IBluetooth) m.invoke(null, b);


		} catch (Exception e) {
			Log.e(TAG, "Erroraco!!! " + e.getMessage());
		}






        blueService.setPropertyBoolean("Pairable", pairable);
        blueService.setPropertyBoolean("Discoverable", discoverable);
        BluetoothService.MESSAGE_DISCOVERABLE_TIMEOUT = 4;
    }

	protected void onActivityResult(int cRequest, int cResult, Intent data)
    {
		if (cRequest == REQUEST_ENABLE_BT) {
			if (cResult == RESULT_OK) {
			}
		}
		if (cRequest == REQUEST_DISCOVERABLE_BT) {
			if (cResult != RESULT_CANCELED) {
				//  result code equal to the duration that the device is discoverable
			}
		}
    }

	protected void onDestroy()
    {
    	blueAdapter.cancelDiscovery();
		unregisterReceiver(receiver);
		unregisterReceiver(stateChange);
		unregisterReceiver(modeChange);
		super.onDestroy();
    }

    protected void onPause()
    {
        // Call user onPause event
        w.tVisitorApp.nRun(w.pi);
    }

    protected void onResume()
    {
        // Call user onResume event
        w.tVisitorApp.nRun(w.rho);
    }

    public void callOnResume()
    {
        // Callback hook from native for protected method
    	super.onResume();
    }

    public void callOnPause()
    {
        // Callback hook from native for protected method
    	super.onPause();
    }

    private class ServeurBluetooth extends Thread {
        private final BluetoothServerSocket blueServerSocket;


        public ServeurBluetooth() {
            //blueAdapter.startLeScan(LeScanCallback)

            // On utilise un objet temporaire qui sera assigné plus tard à blueServerSocket car blueServerSocket est "final"
            BluetoothServerSocket tmp = null;
            try {


            	/*
            	    Issue 29039:	ICS fails to make insecure Bluetooth connections to Honeycomb and Gingerbread

	            	- Steps to reproduce the problem.
	            	invoke "createInsecureRfcommSocket" on remote BluetoothDevice and call connect() on the returned BluetoothSocket.

	            	- What happened.
	            	If the invoking device is running ICS and the remote device is running Honeycomb or Gingerbread, the connection
	            	fails throwing a "java.io.IOException: Invalid exchange"

	            	Please note that the first connection attempt after ICS device reboot appears to succeed. However, all subsequent
	            	attempts fail as described above.

	            	- What you think the correct behavior should be.
	            	BluetoothSocket.connect() should succeed.

	            	This has been tested on Galaxy Nexus 4.0.2 and Nexus S 4.0.4 making insecure Bluetooth connections to Galaxy Tablet
	            	3.2.0, Xperia Mini Pro 2.3.3, and Droid Pro 2.2.1
            	 */

            	/*
            	    I am getting "Invalid Exchange" when using "createInsecureRfcommSocket" on ICS to connect to Debian Linux (bluez)
            	    systems or Windows 7 (Microsoft Stack) systems using Bluetooth 2.1 dongles and Bluecove JSR-82 implementation.
            	    I can also confirm that is works the first time but not on subsequent calls, for some definition of "first time"
            	    (not clear whether local or remote device reboot is required.) It is possibly the same cause as reported above
            	    with Gingerbread devices.

				    This does not happen when respective systems have Bluetooth 2.0 dongles, all else being equal, so it could be
				    related to Bluetooth 2.1, notably Secure Simple Pairing (SSP) and its mandated encryption.

                    Also, when using createInsecureRfcommSocketToServiceRecord instead of createInsecureRfcommSocket (as mandated
                    by ICS really), the failures are the same (works with Bluetooth 2.0, not with 2.1) but the error message is
                    "IOException: Connection Refused".
            	 */

            	/*
            	    Possible workaround: After detecting the "Invalid Exchange" loop back to re-create the socket and re-connect
            	    This works the second time through as long as the retry is done before the baseband link times out
            	 */

            	/*
            		I can confirm that the hack works in the situation described in comment 6, too.
            	 */

            	/*
            	   The solution from awy...@gmail.com (try again on failure) is a successful workaround for me as well.  Thanks so much!
            	 */

            	/*
	            	4.2.2	17	11 février 2013	 Résolution de problèmes Bluetooth
            	 */

            	/*
            	   Bluetooth support was fully re-engineered for Android 4.2. Issues that existed on older versions probably don't
            	   exist any more. If this issue still exists on Android 4.2 or newer, please submit a separate report
            	 */

        		// Secure Simple Pairing (SSP) available on Bluetooth v2.1 devices

            	// FIXME: API 10 ok, but what API on remote device ? see above ... ?
            	if (w.cAPI >= 10) {
            		// "Just works" SSP uses a form of public key cryptography with no MITM protection
            		// No user interaction required - however, a device may prompt the user to confirm the pairing process
	                tmp = blueAdapter.listenUsingInsecureRfcommWithServiceRecord(mServiceName, mUUID);
            	} else if (w.cAPI >= 5) {
            		// SSP Secure Simple Pairing with user interaction
	                tmp = blueAdapter.listenUsingRfcommWithServiceRecord(mServiceName, mUUID);
            	} else {
            		/*
            		BluetoothSocket socket;
            		UUID wellKnownSerialUuid = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
            		BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice("ff:ff:ff:ff:ff:ff"); // fake address :)

            		 // First method to create Bluetooth socket
                    Method m = null;
                    try {
                        m = device.getClass().getMethod("createRfcommSocket", new Class[] {int.class});
                        socket = (BluetoothSocket) m.invoke(device, 1);
                    } catch (SecurityException e) {
                        e.printStackTrace();
                    } catch (NoSuchMethodException e) {
                        e.printStackTrace();
                    } catch (IllegalArgumentException e) {
                        e.printStackTrace();
                    } catch (IllegalAccessException e) {
                        e.printStackTrace();
                    } catch (InvocationTargetException e) {
                        e.printStackTrace();
                    }
                    // Second method to create Bluetooth socket
                    // If the previous was unsuccessful, use yours here
                    socket = device.createRfcommSocketToServiceRecord(wellKnownSerialUuid);

            		socket.connect();
            		socket.close();

            		Method m = device.getClass().getMethod("createInsecureRfcommSocket", new Class[] {int.class});
            		sock = (BluetoothSocket) m.invoke(device, 1);
            		sock.connect();

            		tmp = InsecureBluetooth.listenUsingRfcommWithServiceRecord(mAdapter, NAME, MY_UUID, true);
            		tmp = InsecureBluetooth.createRfcommSocketToServiceRecord(device, MY_UUID, true);
            		*/
            	}
            } catch (IOException e) { }
            blueServerSocket = tmp;
        }

        public void run() {
            BluetoothSocket blueSocket = null;
            // On attend une erreur ou une connexion entrante
            while (true) {
                try {
                    blueSocket = blueServerSocket.accept();
                } catch (IOException e) {
                    break;
                }
                // Si une connexion est acceptée
                if (blueSocket != null) {
                    // On fait ce qu'on veut de la connexion (dans un thread séparé), à vous de la créer
                    manageConnectedSocket(blueSocket);
                    blueServerSocket.close();
                    break;
                }
            }
        }

        // On stoppe l'écoute des connexions et on tue le thread
        public void cancel() {
            try {
                blueServerSocket.close();
            } catch (IOException e) { }
        }
    }

    private class ConnectThread extends Thread {
        private final BluetoothSocket mmSocket;
        private final BluetoothDevice mmDevice;

        public ConnectThread(BluetoothDevice device) {
            // Use a temporary object that is later assigned to mmSocket,
            // because mmSocket is final
            BluetoothSocket tmp = null;
            mmDevice = device;

            // Get a BluetoothSocket to connect with the given BluetoothDevice
            try {
                // MY_UUID is the app's UUID string, also used by the server code
                tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
            } catch (IOException e) { }
            mmSocket = tmp;
        }

        public void run() {
            // Cancel discovery because it will slow down the connection
            mBluetoothAdapter.cancelDiscovery();

            try {
                // Connect the device through the socket. This will block
                // until it succeeds or throws an exception
                mmSocket.connect();
            } catch (IOException connectException) {
                // Unable to connect; close the socket and get out
                try {
                    mmSocket.close();
                } catch (IOException closeException) { }
                return;
            }

            // Do work to manage the connection (in a separate thread)
            manageConnectedSocket(mmSocket);
        }

        /** Will cancel an in-progress connection, and close the socket */
        public void cancel() {
            try {
                mmSocket.close();
            } catch (IOException e) { }
        }
    }

    private class ConnectedThread extends Thread {
        private final BluetoothSocket mmSocket;
        private final InputStream mmInStream;
        private final OutputStream mmOutStream;

        public ConnectedThread(BluetoothSocket socket) {
            mmSocket = socket;
            InputStream tmpIn = null;
            OutputStream tmpOut = null;

            // Get the input and output streams, using temp objects because
            // member streams are final
            try {
                tmpIn = socket.getInputStream();
                tmpOut = socket.getOutputStream();
            } catch (IOException e) { }

            mmInStream = tmpIn;
            mmOutStream = tmpOut;
        }

        public void run() {
            byte[] buffer = new byte[1024];  // buffer store for the stream
            int bytes; // bytes returned from read()

            // Keep listening to the InputStream until an exception occurs
            while (true) {
                try {
                    // Read from the InputStream
                    bytes = mmInStream.read(buffer);
                    // Send the obtained bytes to the UI activity
                    mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer)
                            .sendToTarget();
                } catch (IOException e) {
                    break;
                }
            }
        }

        /* Call this from the main activity to send data to the remote device */
        public void write(byte[] bytes) {
            try {
                mmOutStream.write(bytes);
            } catch (IOException e) { }
        }

        /* Call this from the main activity to shutdown the connection */
        public void cancel() {
            try {
                mmSocket.close();
            } catch (IOException e) { }
        }
    }
}

/*
try {
	Thread.sleep(10000);
} catch (InterruptedException e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}
*/

//jstring Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )
//return (*env)->NewStringUTF(env, "Hello from JNI !");
//(*env)->NewStringUTF(env, outCStr);

//import hashCode.R;

//import android.content.Context;
//import android.content.SharedPreferences;
//import android.view.Gravity;
//import android.view.ViewGroup.LayoutParams;
//import android.widget.AdapterView;
//import android.widget.ArrayAdapter;
//import android.widget.ImageView;
//import android.widget.ImageView.ScaleType;
//import android.widget.LinearLayout;
//import android.widget.Spinner;
//import android.widget.TextView;
//import android.widget.Toast;
//import android.widget.AdapterView.OnItemSelectedListener;
//import android.graphics.Bitmap;
//import android.graphics.Canvas;

//        //setContentView(new AXplorienceView(this));
//        //setContentView(R.layout.main);
//        TextView label = new TextView(this);
//        label.setTextSize(20);
//        label.setGravity(Gravity.CENTER_HORIZONTAL);
//        ImageView pic = new ImageView(this);
//        //pic.setImageResource(R.drawable.matterhorn);
//        pic.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
//        pic.setAdjustViewBounds(true);
//        pic.setScaleType(ScaleType.FIT_XY);
//        pic.setMaxHeight(250);
//        pic.setMaxWidth(250);
//        LinearLayout ll = new LinearLayout(this);
//        ll.setOrientation(LinearLayout.VERTICAL);
//        ll.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
//        ll.setGravity(Gravity.CENTER);
//        ll.addView(label);
//        ll.addView(pic);
//        setContentView((View)ll);
//    }
//
//}
//
//class AXplorienceView extends View {
//    private Bitmap mBitmap;
//    private long mStartTime;
//
//    /* implementend by libplasma.so */
//    private static native void renderPlasma(Bitmap  bitmap, long time_ms);
//
//    public AXplorienceView(Context context) {
//        super(context);
//
//        final int W = 200;
//        final int H = 200;
//
//        mBitmap = Bitmap.createBitmap(W, H, Bitmap.Config.RGB_565);
//        mStartTime = System.currentTimeMillis();
//    }
//
//    @Override protected void onDraw(Canvas canvas) {
//        //canvas.drawColor(0xFFCCCCCC);
//        renderPlasma(mBitmap, System.currentTimeMillis() - mStartTime);
//        canvas.drawBitmap(mBitmap, 0, 0, null);
//        // force a redraw, with a different time-based pattern.
//        invalidate();
//    }
//}
